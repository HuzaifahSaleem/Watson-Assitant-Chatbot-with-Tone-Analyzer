{"version":3,"file":"SVGPathData.js","sources":["../src/mathUtils.ts","../src/SVGPathDataTransformer.ts","../src/TransformableSVG.ts","../src/SVGPathDataParser.ts","../src/SVGPathData.ts","../src/SVGPathDataEncoder.ts","../src/SVGPathData.ts"],"sourcesContent":["import { SVGPathData } from \"./SVGPathData\";\nimport { CommandA, CommandC } from \"./types\";\n\nexport function rotate([x, y]: [number, number], rad: number) {\n  return [\n    x * Math.cos(rad) - y * Math.sin(rad),\n    x * Math.sin(rad) + y * Math.cos(rad),\n  ];\n}\n\nconst DEBUG_CHECK_NUMBERS = true;\nexport function assertNumbers(...numbers: number[]) {\n  if (DEBUG_CHECK_NUMBERS) {\n    for (let i = 0; i < numbers.length; i++) {\n      if (\"number\" !== typeof numbers[i]) {\n        throw new Error(\n          `assertNumbers arguments[${i}] is not a number. ${typeof numbers[i]} == typeof ${numbers[i]}`);\n      }\n    }\n  }\n  return true;\n}\n\nconst PI = Math.PI;\n\n/**\n * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n * Fixes rX and rY.\n * Ensures lArcFlag and sweepFlag are 0 or 1\n * Adds center coordinates: command.cX, command.cY (relative or absolute, depending on command.relative)\n * Adds start and end arc parameters (in degrees): command.phi1, command.phi2; phi1 < phi2 iff. c.sweepFlag == true\n */\nexport function annotateArcCommand(c: CommandA, x1: number, y1: number) {\n  c.lArcFlag = (0 === c.lArcFlag) ? 0 : 1;\n  c.sweepFlag = (0 === c.sweepFlag) ? 0 : 1;\n  // tslint:disable-next-line\n  let {rX, rY, x, y} = c;\n\n  rX = Math.abs(c.rX);\n  rY = Math.abs(c.rY);\n  const [x1_, y1_] = rotate([(x1 - x) / 2, (y1 - y) / 2], -c.xRot / 180 * PI);\n  const testValue = Math.pow(x1_, 2) / Math.pow(rX, 2) + Math.pow(y1_, 2) / Math.pow(rY, 2);\n\n  if (1 < testValue) {\n    rX *= Math.sqrt(testValue);\n    rY *= Math.sqrt(testValue);\n  }\n  c.rX = rX;\n  c.rY = rY;\n  const c_ScaleTemp = (Math.pow(rX, 2) * Math.pow(y1_, 2) + Math.pow(rY, 2) * Math.pow(x1_, 2));\n  const c_Scale = (c.lArcFlag !== c.sweepFlag ? 1 : -1) *\n    Math.sqrt(Math.max(0, (Math.pow(rX, 2) * Math.pow(rY, 2) - c_ScaleTemp) / c_ScaleTemp));\n  const cx_ = rX * y1_ / rY * c_Scale;\n  const cy_ = -rY * x1_ / rX * c_Scale;\n  const cRot = rotate([cx_, cy_], c.xRot / 180 * PI);\n\n  c.cX = cRot[0] + (x1 + x) / 2;\n  c.cY = cRot[1] + (y1 + y) / 2;\n  c.phi1 = Math.atan2((y1_ - cy_) / rY, (x1_ - cx_) / rX);\n  c.phi2 = Math.atan2((-y1_ - cy_) / rY, (-x1_ - cx_) / rX);\n  if (0 === c.sweepFlag && c.phi2 > c.phi1) {\n    c.phi2 -= 2 * PI;\n  }\n  if (1 === c.sweepFlag && c.phi2 < c.phi1) {\n    c.phi2 += 2 * PI;\n  }\n  c.phi1 *= 180 / PI;\n  c.phi2 *= 180 / PI;\n}\n\n/**\n * Solves a quadratic system of equations of the form\n *      a * x + b * y = c\n *      x² + y² = 1\n * This can be understood as the intersection of the unit circle with a line.\n *      => y = (c - a x) / b\n *      => x² + (c - a x)² / b² = 1\n *      => x² b² + c² - 2 c a x + a² x² = b²\n *      => (a² + b²) x² - 2 a c x + (c² - b²) = 0\n */\nexport function intersectionUnitCircleLine(a: number, b: number, c: number): Array<[number, number]> {\n  assertNumbers(a, b, c);\n  // cf. pqFormula\n  const termSqr = a * a + b * b - c * c;\n\n  if (0 > termSqr) {\n    return [];\n  } else if (0 === termSqr) {\n    return [\n      [\n        (a * c) / (a * a + b * b),\n        (b * c) / (a * a + b * b)]];\n  }\n  const term = Math.sqrt(termSqr);\n\n  return [\n    [\n      (a * c + b * term) / (a * a + b * b),\n      (b * c - a * term) / (a * a + b * b)],\n    [\n      (a * c - b * term) / (a * a + b * b),\n      (b * c + a * term) / (a * a + b * b)]];\n\n}\n\nexport const DEG = Math.PI / 180;\n\nexport function lerp(a: number, b: number, t: number) {\n  return (1 - t) * a + t * b;\n}\n\nexport function arcAt(c: number, x1: number, x2: number, phiDeg: number) {\n  return c + Math.cos(phiDeg / 180 * PI) * x1 + Math.sin(phiDeg / 180 * PI) * x2;\n}\n\nexport function bezierRoot(x0: number, x1: number, x2: number, x3: number) {\n  const EPS = 1e-6;\n  const x01 = x1 - x0;\n  const x12 = x2 - x1;\n  const x23 = x3 - x2;\n  const a = 3 * x01 + 3 * x23 - 6 * x12;\n  const b = (x12 - x01) * 6;\n  const c = 3 * x01;\n  // solve a * t² + b * t + c = 0\n\n  if (Math.abs(a) < EPS) {\n    // equivalent to b * t + c =>\n    return [-c / b];\n  }\n  return pqFormula(b / a, c / a, EPS);\n\n}\n\nexport function bezierAt(x0: number, x1: number, x2: number, x3: number, t: number) {\n  // console.log(x0, y0, x1, y1, x2, y2, x3, y3, t)\n  const s = 1 - t;\n  const c0 = s * s * s;\n  const c1 = 3 * s * s * t;\n  const c2 = 3 * s * t * t;\n  const c3 = t * t * t;\n\n  return x0 * c0 + x1 * c1 + x2 * c2 + x3 * c3;\n}\n\nfunction pqFormula(p: number, q: number, PRECISION = 1e-6) {\n  // 4 times the discriminant:in\n  const discriminantX4 = p * p / 4 - q;\n\n  if (discriminantX4 < -PRECISION) {\n    return [];\n  } else if (discriminantX4 <= PRECISION) {\n    return [-p / 2];\n  }\n  const root = Math.sqrt(discriminantX4);\n\n  return [-(p / 2) - root, -(p / 2) + root];\n\n}\n\nexport function a2c(arc: CommandA, x0: number, y0: number): CommandC[] {\n  if (!arc.cX) {\n    annotateArcCommand(arc, x0, y0);\n  }\n\n  const phiMin = Math.min(arc.phi1!, arc.phi2!), phiMax = Math.max(arc.phi1!, arc.phi2!), deltaPhi = phiMax - phiMin;\n  const partCount = Math.ceil(deltaPhi / 90 );\n\n  const result: CommandC[] = new Array(partCount);\n  let prevX = x0, prevY = y0;\n  for (let i = 0; i < partCount; i++) {\n    const phiStart = lerp(arc.phi1!, arc.phi2!, i / partCount);\n    const phiEnd = lerp(arc.phi1!, arc.phi2!, (i + 1) / partCount);\n    const deltaPhi = phiEnd - phiStart;\n    const f = 4 / 3 * Math.tan(deltaPhi * DEG / 4);\n    // x1/y1, x2/y2 and x/y coordinates on the unit circle for phiStart/phiEnd\n    const [x1, y1] = [\n      Math.cos(phiStart * DEG) - f * Math.sin(phiStart * DEG),\n      Math.sin(phiStart * DEG) + f * Math.cos(phiStart * DEG)];\n    const [x, y] = [Math.cos(phiEnd * DEG), Math.sin(phiEnd * DEG)];\n    const [x2, y2] = [x + f * Math.sin(phiEnd * DEG), y - f * Math.cos(phiEnd * DEG)];\n    result[i] = {relative: arc.relative, type: SVGPathData.CURVE_TO } as any;\n    const transform = (x: number, y: number) => {\n      const [xTemp, yTemp] = rotate([x * arc.rX, y * arc.rY], arc.xRot);\n      return [arc.cX! + xTemp, arc.cY! + yTemp];\n    };\n    [result[i].x1, result[i].y1] = transform(x1, y1);\n    [result[i].x2, result[i].y2] = transform(x2, y2);\n    [result[i].x, result[i].y] = transform(x, y);\n    if (arc.relative) {\n      result[i].x1 -= prevX;\n      result[i].y1 -= prevY;\n      result[i].x2 -= prevX;\n      result[i].y2 -= prevY;\n      result[i].x -= prevX;\n      result[i].y -= prevY;\n    }\n    [prevX, prevY] = [result[i].x, result[i].y];\n  }\n  return result;\n}\n","// Transform SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\nimport { a2c, annotateArcCommand, arcAt, assertNumbers, bezierAt, bezierRoot,\n  intersectionUnitCircleLine } from \"./mathUtils\";\nimport { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand, TransformFunction } from \"./types\";\n\nexport namespace SVGPathDataTransformer {\n  // Predefined transforming functions\n  // Rounds commands values\n  export function ROUND(roundVal = 1e13) {\n    assertNumbers(roundVal);\n    function rf(val: number) { return Math.round(val * roundVal) / roundVal; }\n    return function round(command: any) {\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = rf(command.x1);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = rf(command.y1);\n      }\n\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = rf(command.x2);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = rf(command.y2);\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = rf(command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = rf(command.y);\n      }\n\n      return command;\n    };\n  }\n  // Relative to absolute commands\n  export function TO_ABS() {\n    return INFO((command, prevX, prevY) => {\n      if (command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 += prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 += prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x += prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y += prevY;\n        }\n        command.relative = false;\n      }\n      return command;\n    });\n  }\n  // Absolute to relative commands\n  export function TO_REL() {\n    return INFO((command, prevX, prevY) => {\n      if (!command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 -= prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 -= prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y -= prevY;\n        }\n        command.relative = true;\n      }\n      return command;\n    });\n  }\n  // Convert H, V, Z and A with rX = 0 to L\n  export function NORMALIZE_HVZ(normalizeZ = true, normalizeH = true, normalizeV = true) {\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      if (isNaN(pathStartX) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n      if (normalizeH && command.type & SVGPathData.HORIZ_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (normalizeV && command.type & SVGPathData.VERT_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n      if (normalizeZ && command.type & SVGPathData.CLOSE_PATH) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? pathStartX - prevX : pathStartX;\n        command.y = command.relative ? pathStartY - prevY : pathStartY;\n      }\n      if (command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY)) {\n        command.type = SVGPathData.LINE_TO;\n        delete command.rX;\n        delete command.rY;\n        delete command.xRot;\n        delete command.lArcFlag;\n        delete command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  /*\n   * Transforms smooth curves and quads to normal curves and quads (SsTt to CcQq)\n   */\n  export function NORMALIZE_ST() {\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        command.type = SVGPathData.CURVE_TO;\n        prevCurveC2X = isNaN(prevCurveC2X) ? prevX : prevCurveC2X;\n        prevCurveC2Y = isNaN(prevCurveC2Y) ? prevY : prevCurveC2Y;\n        command.x1 = command.relative ? prevX - prevCurveC2X : 2 * prevX - prevCurveC2X;\n        command.y1 = command.relative ? prevY - prevCurveC2Y : 2 * prevY - prevCurveC2Y;\n      }\n      if (command.type & SVGPathData.CURVE_TO) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : prevQuadCY;\n        command.x1 = command.relative ? prevX - prevQuadCX : 2 * prevX - prevQuadCX;\n        command.y1 = command.relative ? prevY - prevQuadCY : 2 * prevY - prevQuadCY;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y1;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      return command;\n    });\n  }\n  /*\n   * A quadratic bézier curve can be represented by a cubic bézier curve which has\n   * the same end points as the quadratic and both control points in place of the\n   * quadratic\"s one.\n   *\n   * This transformer replaces QqTt commands with Cc commands respectively.\n   * This is useful for reading path data into a system which only has a\n   * representation for cubic curves.\n   */\n  export function QT_TO_C() {\n    let prevQuadX1 = NaN;\n    let prevQuadY1 = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadX1 = isNaN(prevQuadX1) ? prevX : prevQuadX1;\n        prevQuadY1 = isNaN(prevQuadY1) ? prevY : prevQuadY1;\n        command.x1 = command.relative ? prevX - prevQuadX1 : 2 * prevX - prevQuadX1;\n        command.y1 = command.relative ? prevY - prevQuadY1 : 2 * prevY - prevQuadY1;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadX1 = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadY1 = command.relative ? prevY + command.y1 : command.y1;\n        const x1 = command.x1;\n        const y1 = command.y1;\n\n        command.type = SVGPathData.CURVE_TO;\n        command.x1 = ((command.relative ? 0 : prevX) + x1 * 2) / 3;\n        command.y1 = ((command.relative ? 0 : prevY) + y1 * 2) / 3;\n        command.x2 = (command.x + x1 * 2) / 3;\n        command.y2 = (command.y + y1 * 2) / 3;\n      } else {\n        prevQuadX1 = NaN;\n        prevQuadY1 = NaN;\n      }\n\n      return command;\n    });\n  }\n  export function INFO(\n    f: (command: any, prevXAbs: number, prevYAbs: number,\n        pathStartXAbs: number, pathStartYAbs: number) => any | any[]) {\n    let prevXAbs = 0;\n    let prevYAbs = 0;\n    let pathStartXAbs = NaN;\n    let pathStartYAbs = NaN;\n\n    return function transform(command: any) {\n      if (isNaN(pathStartXAbs) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n\n      const result = f(command, prevXAbs, prevYAbs, pathStartXAbs, pathStartYAbs);\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        prevXAbs = pathStartXAbs;\n        prevYAbs = pathStartYAbs;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        prevXAbs = (command.relative ? prevXAbs + command.x : command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        prevYAbs = (command.relative ? prevYAbs + command.y : command.y);\n      }\n\n      if (command.type & SVGPathData.MOVE_TO) {\n        pathStartXAbs = prevXAbs;\n        pathStartYAbs = prevYAbs;\n      }\n\n      return result;\n    };\n  }\n  /*\n   * remove 0-length segments\n   */\n  export function SANITIZE(EPS = 0) {\n    assertNumbers(EPS);\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      const abs = Math.abs;\n      let skip = false;\n      let x1Rel = 0;\n      let y1Rel = 0;\n\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        x1Rel = isNaN(prevCurveC2X) ? 0 : prevX - prevCurveC2X;\n        y1Rel = isNaN(prevCurveC2Y) ? 0 : prevY - prevCurveC2Y;\n      }\n      if (command.type & (SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO)) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : 2 * prevX - prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : 2 * prevY - prevQuadCY;\n      } else if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y2;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      if (command.type & SVGPathData.LINE_COMMANDS ||\n        command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY || !command.lArcFlag) ||\n        command.type & SVGPathData.CURVE_TO || command.type & SVGPathData.SMOOTH_CURVE_TO ||\n        command.type & SVGPathData.QUAD_TO || command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        const xRel = \"undefined\" === typeof command.x ? 0 :\n          (command.relative ? command.x : command.x - prevX);\n        const yRel = \"undefined\" === typeof command.y ? 0 :\n          (command.relative ? command.y : command.y - prevY);\n\n        x1Rel = !isNaN(prevQuadCX) ? prevQuadCX - prevX :\n          \"undefined\" === typeof command.x1 ? x1Rel :\n            command.relative ? command.x :\n              command.x1 - prevX;\n        y1Rel = !isNaN(prevQuadCY) ? prevQuadCY - prevY :\n          \"undefined\" === typeof command.y1 ? y1Rel :\n            command.relative ? command.y :\n              command.y1 - prevY;\n\n        const x2Rel = \"undefined\" === typeof command.x2 ? 0 :\n          (command.relative ? command.x : command.x2 - prevX);\n        const y2Rel = \"undefined\" === typeof command.y2 ? 0 :\n          (command.relative ? command.y : command.y2 - prevY);\n\n        if (abs(xRel) <= EPS && abs(yRel) <= EPS &&\n          abs(x1Rel) <= EPS && abs(y1Rel) <= EPS &&\n          abs(x2Rel) <= EPS && abs(y2Rel) <= EPS) {\n          skip = true;\n        }\n      }\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        if (abs(prevX - pathStartX) <= EPS && abs(prevY - pathStartY) <= EPS) {\n          skip = true;\n        }\n      }\n\n      return skip ? [] : command;\n    });\n  }\n  // SVG Transforms : http://www.w3.org/TR/SVGTiny12/coords.html#TransformList\n  // Matrix : http://apike.ca/prog_svg_transform.html\n  // a c e\n  // b d f\n  export function MATRIX(a: number, b: number, c: number, d: number, e: number, f: number) {\n    assertNumbers(a, b, c, d, e, f);\n\n    return INFO((command, prevX, prevY, pathStartX) => {\n      const origX1 = command.x1;\n      const origX2 = command.x2;\n      // if isNaN(pathStartX), then this is the first command, which is ALWAYS an\n      // absolute MOVE_TO, regardless what the relative flag says\n      const comRel = command.relative && !isNaN(pathStartX);\n      const x = \"undefined\" !== typeof command.x ? command.x : (comRel ? 0 : prevX);\n      const y = \"undefined\" !== typeof command.y ? command.y : (comRel ? 0 : prevY);\n\n      if (command.type & SVGPathData.HORIZ_LINE_TO && 0 !== b) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (command.type & SVGPathData.VERT_LINE_TO && 0 !== c) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = (command.x * a) + (y * c) + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = (x * b) + command.y * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = command.x1 * a + command.y1 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = origX1 * b + command.y1 * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = command.x2 * a + command.y2 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = origX2 * b + command.y2 * d + (comRel ? 0 : f);\n      }\n      function sqr(x: number) { return x * x; }\n      const det = a * d - b * c;\n\n      if (\"undefined\" !== typeof command.xRot) {\n        // Skip if this is a pure translation\n        if (1 !== a || 0 !== b || 0 !== c || 1 !== d) {\n          // Special case for singular matrix\n          if (0 === det) {\n            // In the singular case, the arc is compressed to a line. The actual geometric image of the original\n            // curve under this transform possibly extends beyond the starting and/or ending points of the segment, but\n            // for simplicity we ignore this detail and just replace this command with a single line segment.\n            delete command.rX;\n            delete command.rY;\n            delete command.xRot;\n            delete command.lArcFlag;\n            delete command.sweepFlag;\n            command.type = SVGPathData.LINE_TO;\n          } else {\n            // Convert to radians\n            const xRot = command.xRot * Math.PI / 180;\n\n            // Convert rotated ellipse to general conic form\n            // x0^2/rX^2 + y0^2/rY^2 - 1 = 0\n            // x0 = x*cos(xRot) + y*sin(xRot)\n            // y0 = -x*sin(xRot) + y*cos(xRot)\n            // --> A*x^2 + B*x*y + C*y^2 - 1 = 0, where\n            const sinRot = Math.sin(xRot);\n            const cosRot = Math.cos(xRot);\n            const xCurve = 1 / sqr(command.rX);\n            const yCurve = 1 / sqr(command.rY);\n            const A = sqr(cosRot) * xCurve + sqr(sinRot) * yCurve;\n            const B = 2 * sinRot * cosRot * (xCurve - yCurve);\n            const C = sqr(sinRot) * xCurve + sqr(cosRot) * yCurve;\n\n            // Apply matrix to A*x^2 + B*x*y + C*y^2 - 1 = 0\n            // x1 = a*x + c*y\n            // y1 = b*x + d*y\n            //      (we can ignore e and f, since pure translations don\"t affect the shape of the ellipse)\n            // --> A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 = 0, where\n            const A1 = A * d * d - B * b * d + C * b * b;\n            const B1 = B * (a * d + b * c) - 2 * (A * c * d + C * a * b);\n            const C1 = A * c * c - B * a * c + C * a * a;\n\n            // Unapply newXRot to get back to axis-aligned ellipse equation\n            // x1 = x2*cos(newXRot) - y2*sin(newXRot)\n            // y1 = x2*sin(newXRot) + y2*cos(newXRot)\n            // A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 =\n            //   x2^2*(A1*cos(newXRot)^2 + B1*sin(newXRot)*cos(newXRot) + C1*sin(newXRot)^2)\n            //   + x2*y2*(2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2))\n            //   + y2^2*(A1*sin(newXRot)^2 - B1*sin(newXRot)*cos(newXRot) + C1*cos(newXRot)^2)\n            //   (which must have the same zeroes as)\n            // x2^2/newRX^2 + y2^2/newRY^2 - 1\n            //   (so we have)\n            // 2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2) = 0\n            // (A1 - C1)*sin(2*newXRot) = B1*cos(2*newXRot)\n            // 2*newXRot = atan2(B1, A1 - C1)\n            const newXRot = ((Math.atan2(B1, A1 - C1) + Math.PI) % Math.PI) / 2;\n            // For any integer n, (atan2(B1, A1 - C1) + n*pi)/2 is a solution to the above; incrementing n just swaps\n            // the x and y radii computed below (since that\"s what rotating an ellipse by pi/2 does).  Choosing the\n            // rotation between 0 and pi/2 eliminates the ambiguity and leads to more predictable output.\n\n            // Finally, we get newRX and newRY from the same-zeroes relationship that gave us newXRot\n            const newSinRot = Math.sin(newXRot);\n            const newCosRot = Math.cos(newXRot);\n\n            command.rX = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newCosRot) + B1 * newSinRot * newCosRot + C1 * sqr(newSinRot));\n            command.rY = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newSinRot) - B1 * newSinRot * newCosRot + C1 * sqr(newCosRot));\n            command.xRot = newXRot * 180 / Math.PI;\n          }\n        }\n      }\n      // sweepFlag needs to be inverted when mirroring shapes\n      // see http://www.itk.ilstu.edu/faculty/javila/SVG/SVG_drawing1/elliptical_curve.htm\n      // m 65,10 a 50,25 0 1 0 50,25\n      // M 65,60 A 50,25 0 1 1 115,35\n      if (\"undefined\" !== typeof command.sweepFlag && 0 > det) {\n        command.sweepFlag = +!command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  export function ROTATE(a: number, x = 0, y = 0) {\n    assertNumbers(a, x, y);\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    return MATRIX(cos, sin, -sin, cos, x - x * cos + y * sin, y - x * sin - y * cos);\n  }\n  export function TRANSLATE(dX: number, dY = 0) {\n    assertNumbers(dX, dY);\n    return MATRIX(1, 0, 0, 1, dX, dY);\n  }\n  export function SCALE(dX: number, dY = dX) {\n    assertNumbers(dX, dY);\n    return MATRIX(dX, 0, 0, dY, 0, 0);\n  }\n  export function SKEW_X(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, 0, Math.atan(a), 1, 0, 0);\n  }\n  export function SKEW_Y(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, Math.atan(a), 0, 1, 0, 0);\n  }\n  export function X_AXIS_SYMMETRY(xOffset = 0) {\n    assertNumbers(xOffset);\n    return MATRIX(-1, 0, 0, 1, xOffset, 0);\n  }\n  export function Y_AXIS_SYMMETRY(yOffset = 0) {\n    assertNumbers(yOffset);\n    return MATRIX(1, 0, 0, -1, 0, yOffset);\n  }\n  // Convert arc commands to curve commands\n  export function A_TO_C() {\n    return INFO((command, prevX, prevY) => {\n      if (SVGPathData.ARC === command.type) {\n        return a2c(command, command.relative ? 0 : prevX, command.relative ? 0 : prevY);\n      }\n      return command;\n    });\n  }\n  // @see annotateArcCommand\n  export function ANNOTATE_ARCS() {\n    return INFO((c, x1, y1) => {\n      if (c.relative) {\n        x1 = 0;\n        y1 = 0;\n      }\n      if (SVGPathData.ARC === c.type) {\n        annotateArcCommand(c, x1, y1);\n      }\n      return c;\n    });\n  }\n  export function CLONE() {\n    return (c: SVGCommand) => {\n      const result = {} as SVGCommand;\n      // tslint:disable-next-line\n      for (const key in c) {\n        result[key as keyof SVGCommand] = c[key as keyof SVGCommand];\n      }\n      return result;\n    };\n  }\n  // @see annotateArcCommand\n  export function CALCULATE_BOUNDS() {\n    const clone = CLONE();\n    const toAbs = TO_ABS();\n    const qtToC = QT_TO_C();\n    const normST = NORMALIZE_ST();\n    const f: TransformFunction & {minX: number, maxX: number, minY: number, maxY: number} =\n        INFO((command, prevXAbs, prevYAbs) => {\n      const c = normST(qtToC(toAbs(clone(command))));\n      function fixX(absX: number) {\n        if (absX > f.maxX) { f.maxX = absX; }\n        if (absX < f.minX) { f.minX = absX; }\n      }\n      function fixY(absY: number) {\n        if (absY > f.maxY) { f.maxY = absY; }\n        if (absY < f.minY) { f.minY = absY; }\n      }\n      if (c.type & SVGPathData.DRAWING_COMMANDS) {\n        fixX(prevXAbs);\n        fixY(prevYAbs);\n      }\n      if (c.type & SVGPathData.HORIZ_LINE_TO) {\n        fixX(c.x);\n      }\n      if (c.type & SVGPathData.VERT_LINE_TO) {\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.LINE_TO) {\n        fixX(c.x);\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.CURVE_TO) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        const xDerivRoots = bezierRoot(prevXAbs, c.x1, c.x2, c.x);\n\n        for (const derivRoot of xDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixX(bezierAt(prevXAbs, c.x1, c.x2, c.x, derivRoot));\n          }\n        }\n        const yDerivRoots = bezierRoot(prevYAbs, c.y1, c.y2, c.y);\n\n        for (const derivRoot of yDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixY(bezierAt(prevYAbs, c.y1, c.y2, c.y, derivRoot));\n          }\n        }\n      }\n      if (c.type & SVGPathData.ARC) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        annotateArcCommand(c, prevXAbs, prevYAbs);\n        // p = cos(phi) * xv + sin(phi) * yv\n        // dp = -sin(phi) * xv + cos(phi) * yv = 0\n        const xRotRad = c.xRot / 180 * Math.PI;\n        // points on ellipse for phi = 0° and phi = 90°\n        const x0 = Math.cos(xRotRad) * c.rX;\n        const y0 = Math.sin(xRotRad) * c.rX;\n        const x90 = -Math.sin(xRotRad) * c.rY;\n        const y90 = Math.cos(xRotRad) * c.rY;\n\n        // annotateArcCommand returns phi1 and phi2 such that -180° < phi1 < 180° and phi2 is smaller or greater\n        // depending on the sweep flag. Calculate phiMin, phiMax such that -180° < phiMin < 180° and phiMin < phiMax\n        const [phiMin, phiMax] = c.phi1 < c.phi2 ?\n          [c.phi1, c.phi2] :\n          (-180 > c.phi2 ? [c.phi2 + 360, c.phi1 + 360] : [c.phi2, c.phi1]);\n        const normalizeXiEta = ([xi, eta]: [number, number]) => {\n          const phiRad = Math.atan2(eta, xi);\n          const phi = phiRad * 180 / Math.PI;\n\n          return phi < phiMin ? phi + 360 : phi;\n        };\n        // xi = cos(phi), eta = sin(phi)\n\n        const xDerivRoots = intersectionUnitCircleLine(x90, -x0, 0).map(normalizeXiEta);\n        for (const derivRoot of xDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixX(arcAt(c.cX, x0, x90, derivRoot));\n          }\n        }\n\n        const yDerivRoots = intersectionUnitCircleLine(y90, -y0, 0).map(normalizeXiEta);\n        for (const derivRoot of yDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixY(arcAt(c.cY, y0, y90, derivRoot));\n          }\n        }\n      }\n      return command;\n    }) as any;\n\n    f.minX = Infinity;\n    f.maxX = -Infinity;\n    f.minY = Infinity;\n    f.maxY = -Infinity;\n    return f;\n  }\n}\n","import { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformFunction } from \"./types\";\n\nexport abstract class TransformableSVG {\n  round(x?: number) {\n    return this.transform(SVGPathDataTransformer.ROUND(x));\n  }\n\n  toAbs() {\n    return this.transform(SVGPathDataTransformer.TO_ABS());\n  }\n\n  toRel() {\n    return this.transform(SVGPathDataTransformer.TO_REL());\n  }\n\n  normalizeHVZ(a?: boolean, b?: boolean, c?: boolean) {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_HVZ(a, b, c));\n  }\n\n  normalizeST() {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_ST());\n  }\n\n  qtToC() {\n    return this.transform(SVGPathDataTransformer.QT_TO_C());\n  }\n\n  aToC() {\n    return this.transform(SVGPathDataTransformer.A_TO_C());\n  }\n\n  sanitize(eps?: number) {\n    return this.transform(SVGPathDataTransformer.SANITIZE(eps));\n  }\n\n  translate(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.TRANSLATE(x, y));\n  }\n\n  scale(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.SCALE(x, y));\n  }\n\n  rotate(a: number, x?: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.ROTATE(a, x, y));\n  }\n\n  matrix(a: number, b: number, c: number, d: number, e: number, f: number) {\n    return this.transform(SVGPathDataTransformer.MATRIX(a, b, c, d, e, f));\n  }\n\n  skewX(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_X(a));\n  }\n\n  skewY(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_Y(a));\n  }\n\n  xSymmetry(xOffset?: number) {\n    return this.transform(SVGPathDataTransformer.X_AXIS_SYMMETRY(xOffset));\n  }\n\n  ySymmetry(yOffset?: number) {\n    return this.transform(SVGPathDataTransformer.Y_AXIS_SYMMETRY(yOffset));\n  }\n\n  annotateArcs() {\n    return this.transform(SVGPathDataTransformer.ANNOTATE_ARCS());\n  }\n\n  abstract transform(transformFunction: TransformFunction): this;\n}\n","// Parse SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\nimport { SVGPathData, COMMAND_ARG_COUNTS } from './SVGPathData';\nimport { TransformableSVG } from './TransformableSVG';\nimport { SVGCommand, TransformFunction } from './types';\n// Private consts : Char groups\nconst isWhiteSpace = (c: string) => ' ' === c || '\\t' === c || '\\r' === c || '\\n' === c;\nconst isDigit = (c: string) =>\n  '0'.charCodeAt(0) <= c.charCodeAt(0) && c.charCodeAt(0) <= '9'.charCodeAt(0);\nconst COMMANDS = 'mMzZlLhHvVcCsSqQtTaA';\n\nexport class SVGPathDataParser extends TransformableSVG {\n  private curNumber: string = '';\n  private curCommandType: SVGCommand['type'] | -1 = -1;\n  private curCommandRelative = false;\n  private canParseCommandOrComma = true;\n  private curNumberHasExp = false;\n  private curNumberHasExpDigits = false;\n  private curNumberHasDecimal = false;\n  private curArgs: number[] = [];\n\n  constructor() {\n    super();\n  }\n\n  finish(commands: SVGCommand[] = []) {\n    this.parse(' ', commands);\n    // Adding residual command\n    if (0 !== this.curArgs.length || !this.canParseCommandOrComma) {\n      throw new SyntaxError('Unterminated command at the path end.');\n    }\n    return commands;\n  }\n\n  parse(str: string, commands: SVGCommand[] = []) {\n    const finishCommand = (command: SVGCommand) => {\n      commands.push(command);\n      this.curArgs.length = 0;\n      this.canParseCommandOrComma = true;\n    };\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      // White spaces parsing\n\n      if (isDigit(c)) {\n        this.curNumber += c;\n        this.curNumberHasExpDigits = this.curNumberHasExp;\n        continue;\n      }\n      if ('e' === c || 'E' === c) {\n        this.curNumber += c;\n        this.curNumberHasExp = true;\n        continue;\n      }\n      if (('-' === c || '+' === c) && this.curNumberHasExp && !this.curNumberHasExpDigits) {\n        this.curNumber += c;\n        continue;\n      }\n      // if we already have a \".\", it means we are starting a new number\n      if ('.' === c && !this.curNumberHasExp && !this.curNumberHasDecimal) {\n        this.curNumber += c;\n        this.curNumberHasDecimal = true;\n        continue;\n      }\n\n      // New number\n      if (this.curNumber && -1 !== this.curCommandType) {\n        const val = Number(this.curNumber);\n        if (isNaN(val)) {\n          throw new SyntaxError(`Invalid number ending at ${i}`);\n        }\n        if (this.curCommandType === SVGPathData.ARC) {\n          if (0 === this.curArgs.length || 1 === this.curArgs.length) {\n            if (0 > val) {\n              throw new SyntaxError(`Expected positive number, got \"${val}\" at index \"${i}\"`);\n            }\n          } else if (3 === this.curArgs.length || 4 === this.curArgs.length) {\n            if ('0' !== this.curNumber && '1' !== this.curNumber) {\n              throw new SyntaxError(`Expected a flag, got \"${this.curNumber}\" at index \"${i}\"`);\n            }\n          }\n        }\n        this.curArgs.push(val);\n        if (this.curArgs.length === COMMAND_ARG_COUNTS[this.curCommandType]) {\n          if (SVGPathData.HORIZ_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.HORIZ_LINE_TO,\n              relative: this.curCommandRelative,\n              x: val,\n            });\n          } else if (SVGPathData.VERT_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.VERT_LINE_TO,\n              relative: this.curCommandRelative,\n              y: val,\n            });\n            // Move to / line to / smooth quadratic curve to commands (x, y)\n          } else if (\n            this.curCommandType === SVGPathData.MOVE_TO ||\n            this.curCommandType === SVGPathData.LINE_TO ||\n            this.curCommandType === SVGPathData.SMOOTH_QUAD_TO\n          ) {\n            finishCommand({\n              type: this.curCommandType,\n              relative: this.curCommandRelative,\n              x: this.curArgs[0],\n              y: this.curArgs[1],\n            } as SVGCommand);\n            // Switch to line to state\n            if (SVGPathData.MOVE_TO === this.curCommandType) {\n              this.curCommandType = SVGPathData.LINE_TO;\n            }\n          } else if (this.curCommandType === SVGPathData.CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.CURVE_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x2: this.curArgs[2],\n              y2: this.curArgs[3],\n              x: this.curArgs[4],\n              y: this.curArgs[5],\n            });\n          } else if (this.curCommandType === SVGPathData.SMOOTH_CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.SMOOTH_CURVE_TO,\n              relative: this.curCommandRelative,\n              x2: this.curArgs[0],\n              y2: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.QUAD_TO) {\n            finishCommand({\n              type: SVGPathData.QUAD_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.ARC) {\n            finishCommand({\n              type: SVGPathData.ARC,\n              relative: this.curCommandRelative,\n              rX: this.curArgs[0],\n              rY: this.curArgs[1],\n              xRot: this.curArgs[2],\n              lArcFlag: this.curArgs[3] as 0 | 1,\n              sweepFlag: this.curArgs[4] as 0 | 1,\n              x: this.curArgs[5],\n              y: this.curArgs[6],\n            });\n          }\n        }\n        this.curNumber = '';\n        this.curNumberHasExpDigits = false;\n        this.curNumberHasExp = false;\n        this.curNumberHasDecimal = false;\n        this.canParseCommandOrComma = true;\n      }\n      // Continue if a white space or a comma was detected\n      if (isWhiteSpace(c)) {\n        continue;\n      }\n      if (',' === c && this.canParseCommandOrComma) {\n        // L 0,0, H is not valid:\n        this.canParseCommandOrComma = false;\n        continue;\n      }\n      // if a sign is detected, then parse the new number\n      if ('+' === c || '-' === c || '.' === c) {\n        this.curNumber = c;\n        this.curNumberHasDecimal = '.' === c;\n        continue;\n      }\n\n      // Adding residual command\n      if (0 !== this.curArgs.length) {\n        throw new SyntaxError(`Unterminated command at index ${i}.`);\n      }\n      if (!this.canParseCommandOrComma) {\n        throw new SyntaxError(`Unexpected character \"${c}\" at index ${i}. Command cannot follow comma`);\n      }\n      this.canParseCommandOrComma = false;\n      // Detecting the next command\n      if ('z' === c || 'Z' === c) {\n        commands.push({\n          type: SVGPathData.CLOSE_PATH,\n        });\n        this.canParseCommandOrComma = true;\n        this.curCommandType = -1;\n        continue;\n        // Horizontal move to command\n      } else if ('h' === c || 'H' === c) {\n        this.curCommandType = SVGPathData.HORIZ_LINE_TO;\n        this.curCommandRelative = 'h' === c;\n        // Vertical move to command\n      } else if ('v' === c || 'V' === c) {\n        this.curCommandType = SVGPathData.VERT_LINE_TO;\n        this.curCommandRelative = 'v' === c;\n        // Move to command\n      } else if ('m' === c || 'M' === c) {\n        this.curCommandType = SVGPathData.MOVE_TO;\n        this.curCommandRelative = 'm' === c;\n        // Line to command\n      } else if ('l' === c || 'L' === c) {\n        this.curCommandType = SVGPathData.LINE_TO;\n        this.curCommandRelative = 'l' === c;\n        // Curve to command\n      } else if ('c' === c || 'C' === c) {\n        this.curCommandType = SVGPathData.CURVE_TO;\n        this.curCommandRelative = 'c' === c;\n        // Smooth curve to command\n      } else if ('s' === c || 'S' === c) {\n        this.curCommandType = SVGPathData.SMOOTH_CURVE_TO;\n        this.curCommandRelative = 's' === c;\n        // Quadratic bezier curve to command\n      } else if ('q' === c || 'Q' === c) {\n        this.curCommandType = SVGPathData.QUAD_TO;\n        this.curCommandRelative = 'q' === c;\n        // Smooth quadratic bezier curve to command\n      } else if ('t' === c || 'T' === c) {\n        this.curCommandType = SVGPathData.SMOOTH_QUAD_TO;\n        this.curCommandRelative = 't' === c;\n        // Elliptic arc command\n      } else if ('a' === c || 'A' === c) {\n        this.curCommandType = SVGPathData.ARC;\n        this.curCommandRelative = 'a' === c;\n      } else {\n        throw new SyntaxError(`Unexpected character \"${c}\" at index ${i}.`);\n      }\n    }\n    return commands;\n  }\n  /**\n   * Return a wrapper around this parser which applies the transformation on parsed commands.\n   */\n  transform(transform: TransformFunction) {\n    const result = Object.create(this, {\n      parse: {\n        value(chunk: string, commands: SVGCommand[] = []) {\n          const parsedCommands = Object.getPrototypeOf(this).parse.call(\n            this,\n            chunk,\n          );\n          for (const c of parsedCommands) {\n            const cT = transform(c);\n            if (Array.isArray(cT)) {\n              commands.push(...cT);\n            } else {\n              commands.push(cT);\n            }\n          }\n          return commands;\n        },\n      },\n    });\n    return result as this;\n  }\n}\n","import { encodeSVGPath } from \"./SVGPathDataEncoder\";\nimport { SVGPathDataParser } from \"./SVGPathDataParser\";\nimport { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand } from \"./types\";\n\nexport class SVGPathData extends TransformableSVG {\n  commands: SVGCommand[];\n  constructor(content: string | SVGCommand[]) {\n    super();\n    if (\"string\" === typeof content) {\n      this.commands = SVGPathData.parse(content);\n    } else {\n      this.commands = content;\n    }\n  }\n\n  encode() {\n    return SVGPathData.encode(this.commands);\n  }\n\n  getBounds() {\n    const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();\n\n    this.transform(boundsTransform);\n    return boundsTransform;\n  }\n\n  transform(\n    transformFunction: (input: SVGCommand) => SVGCommand | SVGCommand[],\n  ) {\n    const newCommands = [];\n\n    for (const command of this.commands) {\n      const transformedCommand = transformFunction(command);\n\n      if (Array.isArray(transformedCommand)) {\n        newCommands.push(...transformedCommand);\n      } else {\n        newCommands.push(transformedCommand);\n      }\n    }\n    this.commands = newCommands;\n    return this;\n  }\n\n  static encode(commands: SVGCommand[]) {\n    return encodeSVGPath(commands);\n      }\n\n  static parse(path: string) {\n    const parser = new SVGPathDataParser();\n    const commands: SVGCommand[] = [];\n    parser.parse(path, commands);\n    parser.finish(commands);\n    return commands;\n  }\n\n  static readonly CLOSE_PATH: 1 = 1;\n  static readonly MOVE_TO: 2 = 2;\n  static readonly HORIZ_LINE_TO: 4 = 4;\n  static readonly VERT_LINE_TO: 8 = 8;\n  static readonly LINE_TO: 16 = 16;\n  static readonly CURVE_TO: 32 = 32;\n  static readonly SMOOTH_CURVE_TO: 64 = 64;\n  static readonly QUAD_TO: 128 = 128;\n  static readonly SMOOTH_QUAD_TO: 256 = 256;\n  static readonly ARC: 512 = 512;\n  static readonly LINE_COMMANDS = SVGPathData.LINE_TO | SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO;\n  static readonly DRAWING_COMMANDS = SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO | SVGPathData.LINE_TO |\n  SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO | SVGPathData.QUAD_TO |\n  SVGPathData.SMOOTH_QUAD_TO | SVGPathData.ARC;\n}\n\nexport const COMMAND_ARG_COUNTS = {\n    [SVGPathData.MOVE_TO]: 2,\n    [SVGPathData.LINE_TO]: 2,\n    [SVGPathData.HORIZ_LINE_TO]: 1,\n    [SVGPathData.VERT_LINE_TO]: 1,\n    [SVGPathData.CLOSE_PATH]: 0,\n    [SVGPathData.QUAD_TO]: 4,\n    [SVGPathData.SMOOTH_QUAD_TO]: 2,\n    [SVGPathData.CURVE_TO]: 6,\n    [SVGPathData.SMOOTH_CURVE_TO]: 4,\n    [SVGPathData.ARC]: 7,\n};\n\nexport {encodeSVGPath} from \"./SVGPathDataEncoder\"\nexport {SVGPathDataParser} from \"./SVGPathDataParser\"\nexport {SVGPathDataTransformer} from \"./SVGPathDataTransformer\"\n","import { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand } from \"./types\";\n\n// Encode SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\n// Private consts : Char groups\nconst WSP = \" \";\n\nexport function encodeSVGPath(commands: SVGCommand | SVGCommand[]) {\n  let str = \"\";\n\n  if (!Array.isArray(commands)) {\n    commands = [commands];\n  }\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    if (command.type === SVGPathData.CLOSE_PATH) {\n      str += \"z\";\n    } else if (command.type === SVGPathData.HORIZ_LINE_TO) {\n      str += (command.relative ? \"h\" : \"H\") +\n        command.x;\n    } else if (command.type === SVGPathData.VERT_LINE_TO) {\n      str += (command.relative ? \"v\" : \"V\") +\n        command.y;\n    } else if (command.type === SVGPathData.MOVE_TO) {\n      str += (command.relative ? \"m\" : \"M\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.LINE_TO) {\n      str += (command.relative ? \"l\" : \"L\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.CURVE_TO) {\n      str += (command.relative ? \"c\" : \"C\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_CURVE_TO) {\n      str += (command.relative ? \"s\" : \"S\") +\n        command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.QUAD_TO) {\n      str += (command.relative ? \"q\" : \"Q\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_QUAD_TO) {\n      str += (command.relative ? \"t\" : \"T\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.ARC) {\n      str += (command.relative ? \"a\" : \"A\") +\n        command.rX + WSP + command.rY +\n        WSP + command.xRot +\n        WSP + (+command.lArcFlag) + WSP + (+command.sweepFlag) +\n        WSP + command.x + WSP + command.y;\n    } else {\n      // Unknown command\n      throw new Error(\n        `Unexpected command type \"${ (command as any).type}\" at index ${i}.`);\n    }\n  }\n\n  return str;\n}\n","import { encodeSVGPath } from \"./SVGPathDataEncoder\";\nimport { SVGPathDataParser } from \"./SVGPathDataParser\";\nimport { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand } from \"./types\";\n\nexport class SVGPathData extends TransformableSVG {\n  commands: SVGCommand[];\n  constructor(content: string | SVGCommand[]) {\n    super();\n    if (\"string\" === typeof content) {\n      this.commands = SVGPathData.parse(content);\n    } else {\n      this.commands = content;\n    }\n  }\n\n  encode() {\n    return SVGPathData.encode(this.commands);\n  }\n\n  getBounds() {\n    const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();\n\n    this.transform(boundsTransform);\n    return boundsTransform;\n  }\n\n  transform(\n    transformFunction: (input: SVGCommand) => SVGCommand | SVGCommand[],\n  ) {\n    const newCommands = [];\n\n    for (const command of this.commands) {\n      const transformedCommand = transformFunction(command);\n\n      if (Array.isArray(transformedCommand)) {\n        newCommands.push(...transformedCommand);\n      } else {\n        newCommands.push(transformedCommand);\n      }\n    }\n    this.commands = newCommands;\n    return this;\n  }\n\n  static encode(commands: SVGCommand[]) {\n    return encodeSVGPath(commands);\n      }\n\n  static parse(path: string) {\n    const parser = new SVGPathDataParser();\n    const commands: SVGCommand[] = [];\n    parser.parse(path, commands);\n    parser.finish(commands);\n    return commands;\n  }\n\n  static readonly CLOSE_PATH: 1 = 1;\n  static readonly MOVE_TO: 2 = 2;\n  static readonly HORIZ_LINE_TO: 4 = 4;\n  static readonly VERT_LINE_TO: 8 = 8;\n  static readonly LINE_TO: 16 = 16;\n  static readonly CURVE_TO: 32 = 32;\n  static readonly SMOOTH_CURVE_TO: 64 = 64;\n  static readonly QUAD_TO: 128 = 128;\n  static readonly SMOOTH_QUAD_TO: 256 = 256;\n  static readonly ARC: 512 = 512;\n  static readonly LINE_COMMANDS = SVGPathData.LINE_TO | SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO;\n  static readonly DRAWING_COMMANDS = SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO | SVGPathData.LINE_TO |\n  SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO | SVGPathData.QUAD_TO |\n  SVGPathData.SMOOTH_QUAD_TO | SVGPathData.ARC;\n}\n\nexport const COMMAND_ARG_COUNTS = {\n    [SVGPathData.MOVE_TO]: 2,\n    [SVGPathData.LINE_TO]: 2,\n    [SVGPathData.HORIZ_LINE_TO]: 1,\n    [SVGPathData.VERT_LINE_TO]: 1,\n    [SVGPathData.CLOSE_PATH]: 0,\n    [SVGPathData.QUAD_TO]: 4,\n    [SVGPathData.SMOOTH_QUAD_TO]: 2,\n    [SVGPathData.CURVE_TO]: 6,\n    [SVGPathData.SMOOTH_CURVE_TO]: 4,\n    [SVGPathData.ARC]: 7,\n};\n\nexport {encodeSVGPath} from \"./SVGPathDataEncoder\"\nexport {SVGPathDataParser} from \"./SVGPathDataParser\"\nexport {SVGPathDataTransformer} from \"./SVGPathDataTransformer\"\n"],"names":["_a","rad","x","y","Math","cos","sin","_i","numbers","i","length","Error","PI","c","x1","y1","lArcFlag","sweepFlag","rX","rY","abs","x1_","y1_","testValue","pow","sqrt","c_ScaleTemp","c_Scale","max","cx_","cy_","cRot","rotate","xRot","cX","cY","phi1","atan2","phi2","a","b","assertNumbers","termSqr","term","DEG","t","x2","phiDeg","x0","x3","x01","x12","p","q","PRECISION","discriminantX4","root","pqFormula","s","SVGPathDataTransformer","INFO","command","prevX","prevY","relative","y2","prevCurveC2X","NaN","prevCurveC2Y","prevQuadCX","prevQuadCY","type","SVGPathData","SMOOTH_CURVE_TO","CURVE_TO","isNaN","SMOOTH_QUAD_TO","QUAD_TO","prevQuadX1","prevQuadY1","f","prevXAbs","prevYAbs","pathStartXAbs","pathStartYAbs","MOVE_TO","result","CLOSE_PATH","d","e","pathStartX","origX1","origX2","comRel","HORIZ_LINE_TO","LINE_TO","VERT_LINE_TO","det","sinRot","cosRot","xCurve","sqr","yCurve","A","B","C","A1","B1","C1","newXRot","newSinRot","newCosRot","key","roundVal","val","round","rf","normalizeZ","normalizeH","normalizeV","pathStartY","ARC","EPS","skip","x1Rel","y1Rel","LINE_COMMANDS","xRel","yRel","x2Rel","y2Rel","MATRIX","dX","dY","atan","xOffset","yOffset","arc","y0","annotateArcCommand","phiMin","min","deltaPhi","partCount","ceil","Array","phiStart","lerp","phiEnd","deltaPhi_1","tan","_e","_f","_g","transform","xTemp","yTemp","_b","_c","_d","a2c","clone","toAbs","TO_ABS","qtToC","QT_TO_C","normST","NORMALIZE_ST","absX","maxX","minX","absY","maxY","minY","DRAWING_COMMANDS","fixX","fixY","xDerivRoots_1","bezierRoot","derivRoot","bezierAt","yDerivRoots_1","xRotRad","x90","y90","phiMin_1","phiMax","normalizeXiEta","xi","eta","phi","xDerivRoots_2","intersectionUnitCircleLine","map","arcAt","yDerivRoots_2","Infinity","TransformableSVG","this","ROUND","TO_REL","NORMALIZE_HVZ","A_TO_C","eps","SANITIZE","TRANSLATE","SCALE","ROTATE","SKEW_X","SKEW_Y","X_AXIS_SYMMETRY","Y_AXIS_SYMMETRY","ANNOTATE_ARCS","isWhiteSpace","isDigit","charCodeAt","_super","_this","tslib_1.__extends","SVGPathDataParser","commands","parse","curArgs","canParseCommandOrComma","SyntaxError","str","finishCommand","push","curNumber","curNumberHasExpDigits","curNumberHasExp","curNumberHasDecimal","curCommandType","Number","COMMAND_ARG_COUNTS","curCommandRelative","Object","create","value","chunk","parsedCommands_1","getPrototypeOf","call","cT","isArray","content","encode","boundsTransform","CALCULATE_BOUNDS","transformFunction","newCommands","transformedCommand","encodeSVGPath","path","parser","finish","WSP"],"mappings":"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"}