{"version":3,"file":"SVGPathData.module.js","sources":["../src/mathUtils.ts","../src/SVGPathDataTransformer.ts","../src/TransformableSVG.ts","../src/SVGPathDataParser.ts","../src/SVGPathData.ts","../src/SVGPathDataEncoder.ts","../src/SVGPathData.ts"],"sourcesContent":["import { SVGPathData } from \"./SVGPathData\";\nimport { CommandA, CommandC } from \"./types\";\n\nexport function rotate([x, y]: [number, number], rad: number) {\n  return [\n    x * Math.cos(rad) - y * Math.sin(rad),\n    x * Math.sin(rad) + y * Math.cos(rad),\n  ];\n}\n\nconst DEBUG_CHECK_NUMBERS = true;\nexport function assertNumbers(...numbers: number[]) {\n  if (DEBUG_CHECK_NUMBERS) {\n    for (let i = 0; i < numbers.length; i++) {\n      if (\"number\" !== typeof numbers[i]) {\n        throw new Error(\n          `assertNumbers arguments[${i}] is not a number. ${typeof numbers[i]} == typeof ${numbers[i]}`);\n      }\n    }\n  }\n  return true;\n}\n\nconst PI = Math.PI;\n\n/**\n * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n * Fixes rX and rY.\n * Ensures lArcFlag and sweepFlag are 0 or 1\n * Adds center coordinates: command.cX, command.cY (relative or absolute, depending on command.relative)\n * Adds start and end arc parameters (in degrees): command.phi1, command.phi2; phi1 < phi2 iff. c.sweepFlag == true\n */\nexport function annotateArcCommand(c: CommandA, x1: number, y1: number) {\n  c.lArcFlag = (0 === c.lArcFlag) ? 0 : 1;\n  c.sweepFlag = (0 === c.sweepFlag) ? 0 : 1;\n  // tslint:disable-next-line\n  let {rX, rY, x, y} = c;\n\n  rX = Math.abs(c.rX);\n  rY = Math.abs(c.rY);\n  const [x1_, y1_] = rotate([(x1 - x) / 2, (y1 - y) / 2], -c.xRot / 180 * PI);\n  const testValue = Math.pow(x1_, 2) / Math.pow(rX, 2) + Math.pow(y1_, 2) / Math.pow(rY, 2);\n\n  if (1 < testValue) {\n    rX *= Math.sqrt(testValue);\n    rY *= Math.sqrt(testValue);\n  }\n  c.rX = rX;\n  c.rY = rY;\n  const c_ScaleTemp = (Math.pow(rX, 2) * Math.pow(y1_, 2) + Math.pow(rY, 2) * Math.pow(x1_, 2));\n  const c_Scale = (c.lArcFlag !== c.sweepFlag ? 1 : -1) *\n    Math.sqrt(Math.max(0, (Math.pow(rX, 2) * Math.pow(rY, 2) - c_ScaleTemp) / c_ScaleTemp));\n  const cx_ = rX * y1_ / rY * c_Scale;\n  const cy_ = -rY * x1_ / rX * c_Scale;\n  const cRot = rotate([cx_, cy_], c.xRot / 180 * PI);\n\n  c.cX = cRot[0] + (x1 + x) / 2;\n  c.cY = cRot[1] + (y1 + y) / 2;\n  c.phi1 = Math.atan2((y1_ - cy_) / rY, (x1_ - cx_) / rX);\n  c.phi2 = Math.atan2((-y1_ - cy_) / rY, (-x1_ - cx_) / rX);\n  if (0 === c.sweepFlag && c.phi2 > c.phi1) {\n    c.phi2 -= 2 * PI;\n  }\n  if (1 === c.sweepFlag && c.phi2 < c.phi1) {\n    c.phi2 += 2 * PI;\n  }\n  c.phi1 *= 180 / PI;\n  c.phi2 *= 180 / PI;\n}\n\n/**\n * Solves a quadratic system of equations of the form\n *      a * x + b * y = c\n *      x² + y² = 1\n * This can be understood as the intersection of the unit circle with a line.\n *      => y = (c - a x) / b\n *      => x² + (c - a x)² / b² = 1\n *      => x² b² + c² - 2 c a x + a² x² = b²\n *      => (a² + b²) x² - 2 a c x + (c² - b²) = 0\n */\nexport function intersectionUnitCircleLine(a: number, b: number, c: number): Array<[number, number]> {\n  assertNumbers(a, b, c);\n  // cf. pqFormula\n  const termSqr = a * a + b * b - c * c;\n\n  if (0 > termSqr) {\n    return [];\n  } else if (0 === termSqr) {\n    return [\n      [\n        (a * c) / (a * a + b * b),\n        (b * c) / (a * a + b * b)]];\n  }\n  const term = Math.sqrt(termSqr);\n\n  return [\n    [\n      (a * c + b * term) / (a * a + b * b),\n      (b * c - a * term) / (a * a + b * b)],\n    [\n      (a * c - b * term) / (a * a + b * b),\n      (b * c + a * term) / (a * a + b * b)]];\n\n}\n\nexport const DEG = Math.PI / 180;\n\nexport function lerp(a: number, b: number, t: number) {\n  return (1 - t) * a + t * b;\n}\n\nexport function arcAt(c: number, x1: number, x2: number, phiDeg: number) {\n  return c + Math.cos(phiDeg / 180 * PI) * x1 + Math.sin(phiDeg / 180 * PI) * x2;\n}\n\nexport function bezierRoot(x0: number, x1: number, x2: number, x3: number) {\n  const EPS = 1e-6;\n  const x01 = x1 - x0;\n  const x12 = x2 - x1;\n  const x23 = x3 - x2;\n  const a = 3 * x01 + 3 * x23 - 6 * x12;\n  const b = (x12 - x01) * 6;\n  const c = 3 * x01;\n  // solve a * t² + b * t + c = 0\n\n  if (Math.abs(a) < EPS) {\n    // equivalent to b * t + c =>\n    return [-c / b];\n  }\n  return pqFormula(b / a, c / a, EPS);\n\n}\n\nexport function bezierAt(x0: number, x1: number, x2: number, x3: number, t: number) {\n  // console.log(x0, y0, x1, y1, x2, y2, x3, y3, t)\n  const s = 1 - t;\n  const c0 = s * s * s;\n  const c1 = 3 * s * s * t;\n  const c2 = 3 * s * t * t;\n  const c3 = t * t * t;\n\n  return x0 * c0 + x1 * c1 + x2 * c2 + x3 * c3;\n}\n\nfunction pqFormula(p: number, q: number, PRECISION = 1e-6) {\n  // 4 times the discriminant:in\n  const discriminantX4 = p * p / 4 - q;\n\n  if (discriminantX4 < -PRECISION) {\n    return [];\n  } else if (discriminantX4 <= PRECISION) {\n    return [-p / 2];\n  }\n  const root = Math.sqrt(discriminantX4);\n\n  return [-(p / 2) - root, -(p / 2) + root];\n\n}\n\nexport function a2c(arc: CommandA, x0: number, y0: number): CommandC[] {\n  if (!arc.cX) {\n    annotateArcCommand(arc, x0, y0);\n  }\n\n  const phiMin = Math.min(arc.phi1!, arc.phi2!), phiMax = Math.max(arc.phi1!, arc.phi2!), deltaPhi = phiMax - phiMin;\n  const partCount = Math.ceil(deltaPhi / 90 );\n\n  const result: CommandC[] = new Array(partCount);\n  let prevX = x0, prevY = y0;\n  for (let i = 0; i < partCount; i++) {\n    const phiStart = lerp(arc.phi1!, arc.phi2!, i / partCount);\n    const phiEnd = lerp(arc.phi1!, arc.phi2!, (i + 1) / partCount);\n    const deltaPhi = phiEnd - phiStart;\n    const f = 4 / 3 * Math.tan(deltaPhi * DEG / 4);\n    // x1/y1, x2/y2 and x/y coordinates on the unit circle for phiStart/phiEnd\n    const [x1, y1] = [\n      Math.cos(phiStart * DEG) - f * Math.sin(phiStart * DEG),\n      Math.sin(phiStart * DEG) + f * Math.cos(phiStart * DEG)];\n    const [x, y] = [Math.cos(phiEnd * DEG), Math.sin(phiEnd * DEG)];\n    const [x2, y2] = [x + f * Math.sin(phiEnd * DEG), y - f * Math.cos(phiEnd * DEG)];\n    result[i] = {relative: arc.relative, type: SVGPathData.CURVE_TO } as any;\n    const transform = (x: number, y: number) => {\n      const [xTemp, yTemp] = rotate([x * arc.rX, y * arc.rY], arc.xRot);\n      return [arc.cX! + xTemp, arc.cY! + yTemp];\n    };\n    [result[i].x1, result[i].y1] = transform(x1, y1);\n    [result[i].x2, result[i].y2] = transform(x2, y2);\n    [result[i].x, result[i].y] = transform(x, y);\n    if (arc.relative) {\n      result[i].x1 -= prevX;\n      result[i].y1 -= prevY;\n      result[i].x2 -= prevX;\n      result[i].y2 -= prevY;\n      result[i].x -= prevX;\n      result[i].y -= prevY;\n    }\n    [prevX, prevY] = [result[i].x, result[i].y];\n  }\n  return result;\n}\n","// Transform SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\nimport { a2c, annotateArcCommand, arcAt, assertNumbers, bezierAt, bezierRoot,\n  intersectionUnitCircleLine } from \"./mathUtils\";\nimport { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand, TransformFunction } from \"./types\";\n\nexport namespace SVGPathDataTransformer {\n  // Predefined transforming functions\n  // Rounds commands values\n  export function ROUND(roundVal = 1e13) {\n    assertNumbers(roundVal);\n    function rf(val: number) { return Math.round(val * roundVal) / roundVal; }\n    return function round(command: any) {\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = rf(command.x1);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = rf(command.y1);\n      }\n\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = rf(command.x2);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = rf(command.y2);\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = rf(command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = rf(command.y);\n      }\n\n      return command;\n    };\n  }\n  // Relative to absolute commands\n  export function TO_ABS() {\n    return INFO((command, prevX, prevY) => {\n      if (command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 += prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 += prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x += prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y += prevY;\n        }\n        command.relative = false;\n      }\n      return command;\n    });\n  }\n  // Absolute to relative commands\n  export function TO_REL() {\n    return INFO((command, prevX, prevY) => {\n      if (!command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 -= prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 -= prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y -= prevY;\n        }\n        command.relative = true;\n      }\n      return command;\n    });\n  }\n  // Convert H, V, Z and A with rX = 0 to L\n  export function NORMALIZE_HVZ(normalizeZ = true, normalizeH = true, normalizeV = true) {\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      if (isNaN(pathStartX) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n      if (normalizeH && command.type & SVGPathData.HORIZ_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (normalizeV && command.type & SVGPathData.VERT_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n      if (normalizeZ && command.type & SVGPathData.CLOSE_PATH) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? pathStartX - prevX : pathStartX;\n        command.y = command.relative ? pathStartY - prevY : pathStartY;\n      }\n      if (command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY)) {\n        command.type = SVGPathData.LINE_TO;\n        delete command.rX;\n        delete command.rY;\n        delete command.xRot;\n        delete command.lArcFlag;\n        delete command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  /*\n   * Transforms smooth curves and quads to normal curves and quads (SsTt to CcQq)\n   */\n  export function NORMALIZE_ST() {\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        command.type = SVGPathData.CURVE_TO;\n        prevCurveC2X = isNaN(prevCurveC2X) ? prevX : prevCurveC2X;\n        prevCurveC2Y = isNaN(prevCurveC2Y) ? prevY : prevCurveC2Y;\n        command.x1 = command.relative ? prevX - prevCurveC2X : 2 * prevX - prevCurveC2X;\n        command.y1 = command.relative ? prevY - prevCurveC2Y : 2 * prevY - prevCurveC2Y;\n      }\n      if (command.type & SVGPathData.CURVE_TO) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : prevQuadCY;\n        command.x1 = command.relative ? prevX - prevQuadCX : 2 * prevX - prevQuadCX;\n        command.y1 = command.relative ? prevY - prevQuadCY : 2 * prevY - prevQuadCY;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y1;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      return command;\n    });\n  }\n  /*\n   * A quadratic bézier curve can be represented by a cubic bézier curve which has\n   * the same end points as the quadratic and both control points in place of the\n   * quadratic\"s one.\n   *\n   * This transformer replaces QqTt commands with Cc commands respectively.\n   * This is useful for reading path data into a system which only has a\n   * representation for cubic curves.\n   */\n  export function QT_TO_C() {\n    let prevQuadX1 = NaN;\n    let prevQuadY1 = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadX1 = isNaN(prevQuadX1) ? prevX : prevQuadX1;\n        prevQuadY1 = isNaN(prevQuadY1) ? prevY : prevQuadY1;\n        command.x1 = command.relative ? prevX - prevQuadX1 : 2 * prevX - prevQuadX1;\n        command.y1 = command.relative ? prevY - prevQuadY1 : 2 * prevY - prevQuadY1;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadX1 = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadY1 = command.relative ? prevY + command.y1 : command.y1;\n        const x1 = command.x1;\n        const y1 = command.y1;\n\n        command.type = SVGPathData.CURVE_TO;\n        command.x1 = ((command.relative ? 0 : prevX) + x1 * 2) / 3;\n        command.y1 = ((command.relative ? 0 : prevY) + y1 * 2) / 3;\n        command.x2 = (command.x + x1 * 2) / 3;\n        command.y2 = (command.y + y1 * 2) / 3;\n      } else {\n        prevQuadX1 = NaN;\n        prevQuadY1 = NaN;\n      }\n\n      return command;\n    });\n  }\n  export function INFO(\n    f: (command: any, prevXAbs: number, prevYAbs: number,\n        pathStartXAbs: number, pathStartYAbs: number) => any | any[]) {\n    let prevXAbs = 0;\n    let prevYAbs = 0;\n    let pathStartXAbs = NaN;\n    let pathStartYAbs = NaN;\n\n    return function transform(command: any) {\n      if (isNaN(pathStartXAbs) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n\n      const result = f(command, prevXAbs, prevYAbs, pathStartXAbs, pathStartYAbs);\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        prevXAbs = pathStartXAbs;\n        prevYAbs = pathStartYAbs;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        prevXAbs = (command.relative ? prevXAbs + command.x : command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        prevYAbs = (command.relative ? prevYAbs + command.y : command.y);\n      }\n\n      if (command.type & SVGPathData.MOVE_TO) {\n        pathStartXAbs = prevXAbs;\n        pathStartYAbs = prevYAbs;\n      }\n\n      return result;\n    };\n  }\n  /*\n   * remove 0-length segments\n   */\n  export function SANITIZE(EPS = 0) {\n    assertNumbers(EPS);\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      const abs = Math.abs;\n      let skip = false;\n      let x1Rel = 0;\n      let y1Rel = 0;\n\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        x1Rel = isNaN(prevCurveC2X) ? 0 : prevX - prevCurveC2X;\n        y1Rel = isNaN(prevCurveC2Y) ? 0 : prevY - prevCurveC2Y;\n      }\n      if (command.type & (SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO)) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : 2 * prevX - prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : 2 * prevY - prevQuadCY;\n      } else if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y2;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      if (command.type & SVGPathData.LINE_COMMANDS ||\n        command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY || !command.lArcFlag) ||\n        command.type & SVGPathData.CURVE_TO || command.type & SVGPathData.SMOOTH_CURVE_TO ||\n        command.type & SVGPathData.QUAD_TO || command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        const xRel = \"undefined\" === typeof command.x ? 0 :\n          (command.relative ? command.x : command.x - prevX);\n        const yRel = \"undefined\" === typeof command.y ? 0 :\n          (command.relative ? command.y : command.y - prevY);\n\n        x1Rel = !isNaN(prevQuadCX) ? prevQuadCX - prevX :\n          \"undefined\" === typeof command.x1 ? x1Rel :\n            command.relative ? command.x :\n              command.x1 - prevX;\n        y1Rel = !isNaN(prevQuadCY) ? prevQuadCY - prevY :\n          \"undefined\" === typeof command.y1 ? y1Rel :\n            command.relative ? command.y :\n              command.y1 - prevY;\n\n        const x2Rel = \"undefined\" === typeof command.x2 ? 0 :\n          (command.relative ? command.x : command.x2 - prevX);\n        const y2Rel = \"undefined\" === typeof command.y2 ? 0 :\n          (command.relative ? command.y : command.y2 - prevY);\n\n        if (abs(xRel) <= EPS && abs(yRel) <= EPS &&\n          abs(x1Rel) <= EPS && abs(y1Rel) <= EPS &&\n          abs(x2Rel) <= EPS && abs(y2Rel) <= EPS) {\n          skip = true;\n        }\n      }\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        if (abs(prevX - pathStartX) <= EPS && abs(prevY - pathStartY) <= EPS) {\n          skip = true;\n        }\n      }\n\n      return skip ? [] : command;\n    });\n  }\n  // SVG Transforms : http://www.w3.org/TR/SVGTiny12/coords.html#TransformList\n  // Matrix : http://apike.ca/prog_svg_transform.html\n  // a c e\n  // b d f\n  export function MATRIX(a: number, b: number, c: number, d: number, e: number, f: number) {\n    assertNumbers(a, b, c, d, e, f);\n\n    return INFO((command, prevX, prevY, pathStartX) => {\n      const origX1 = command.x1;\n      const origX2 = command.x2;\n      // if isNaN(pathStartX), then this is the first command, which is ALWAYS an\n      // absolute MOVE_TO, regardless what the relative flag says\n      const comRel = command.relative && !isNaN(pathStartX);\n      const x = \"undefined\" !== typeof command.x ? command.x : (comRel ? 0 : prevX);\n      const y = \"undefined\" !== typeof command.y ? command.y : (comRel ? 0 : prevY);\n\n      if (command.type & SVGPathData.HORIZ_LINE_TO && 0 !== b) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (command.type & SVGPathData.VERT_LINE_TO && 0 !== c) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = (command.x * a) + (y * c) + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = (x * b) + command.y * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = command.x1 * a + command.y1 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = origX1 * b + command.y1 * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = command.x2 * a + command.y2 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = origX2 * b + command.y2 * d + (comRel ? 0 : f);\n      }\n      function sqr(x: number) { return x * x; }\n      const det = a * d - b * c;\n\n      if (\"undefined\" !== typeof command.xRot) {\n        // Skip if this is a pure translation\n        if (1 !== a || 0 !== b || 0 !== c || 1 !== d) {\n          // Special case for singular matrix\n          if (0 === det) {\n            // In the singular case, the arc is compressed to a line. The actual geometric image of the original\n            // curve under this transform possibly extends beyond the starting and/or ending points of the segment, but\n            // for simplicity we ignore this detail and just replace this command with a single line segment.\n            delete command.rX;\n            delete command.rY;\n            delete command.xRot;\n            delete command.lArcFlag;\n            delete command.sweepFlag;\n            command.type = SVGPathData.LINE_TO;\n          } else {\n            // Convert to radians\n            const xRot = command.xRot * Math.PI / 180;\n\n            // Convert rotated ellipse to general conic form\n            // x0^2/rX^2 + y0^2/rY^2 - 1 = 0\n            // x0 = x*cos(xRot) + y*sin(xRot)\n            // y0 = -x*sin(xRot) + y*cos(xRot)\n            // --> A*x^2 + B*x*y + C*y^2 - 1 = 0, where\n            const sinRot = Math.sin(xRot);\n            const cosRot = Math.cos(xRot);\n            const xCurve = 1 / sqr(command.rX);\n            const yCurve = 1 / sqr(command.rY);\n            const A = sqr(cosRot) * xCurve + sqr(sinRot) * yCurve;\n            const B = 2 * sinRot * cosRot * (xCurve - yCurve);\n            const C = sqr(sinRot) * xCurve + sqr(cosRot) * yCurve;\n\n            // Apply matrix to A*x^2 + B*x*y + C*y^2 - 1 = 0\n            // x1 = a*x + c*y\n            // y1 = b*x + d*y\n            //      (we can ignore e and f, since pure translations don\"t affect the shape of the ellipse)\n            // --> A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 = 0, where\n            const A1 = A * d * d - B * b * d + C * b * b;\n            const B1 = B * (a * d + b * c) - 2 * (A * c * d + C * a * b);\n            const C1 = A * c * c - B * a * c + C * a * a;\n\n            // Unapply newXRot to get back to axis-aligned ellipse equation\n            // x1 = x2*cos(newXRot) - y2*sin(newXRot)\n            // y1 = x2*sin(newXRot) + y2*cos(newXRot)\n            // A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 =\n            //   x2^2*(A1*cos(newXRot)^2 + B1*sin(newXRot)*cos(newXRot) + C1*sin(newXRot)^2)\n            //   + x2*y2*(2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2))\n            //   + y2^2*(A1*sin(newXRot)^2 - B1*sin(newXRot)*cos(newXRot) + C1*cos(newXRot)^2)\n            //   (which must have the same zeroes as)\n            // x2^2/newRX^2 + y2^2/newRY^2 - 1\n            //   (so we have)\n            // 2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2) = 0\n            // (A1 - C1)*sin(2*newXRot) = B1*cos(2*newXRot)\n            // 2*newXRot = atan2(B1, A1 - C1)\n            const newXRot = ((Math.atan2(B1, A1 - C1) + Math.PI) % Math.PI) / 2;\n            // For any integer n, (atan2(B1, A1 - C1) + n*pi)/2 is a solution to the above; incrementing n just swaps\n            // the x and y radii computed below (since that\"s what rotating an ellipse by pi/2 does).  Choosing the\n            // rotation between 0 and pi/2 eliminates the ambiguity and leads to more predictable output.\n\n            // Finally, we get newRX and newRY from the same-zeroes relationship that gave us newXRot\n            const newSinRot = Math.sin(newXRot);\n            const newCosRot = Math.cos(newXRot);\n\n            command.rX = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newCosRot) + B1 * newSinRot * newCosRot + C1 * sqr(newSinRot));\n            command.rY = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newSinRot) - B1 * newSinRot * newCosRot + C1 * sqr(newCosRot));\n            command.xRot = newXRot * 180 / Math.PI;\n          }\n        }\n      }\n      // sweepFlag needs to be inverted when mirroring shapes\n      // see http://www.itk.ilstu.edu/faculty/javila/SVG/SVG_drawing1/elliptical_curve.htm\n      // m 65,10 a 50,25 0 1 0 50,25\n      // M 65,60 A 50,25 0 1 1 115,35\n      if (\"undefined\" !== typeof command.sweepFlag && 0 > det) {\n        command.sweepFlag = +!command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  export function ROTATE(a: number, x = 0, y = 0) {\n    assertNumbers(a, x, y);\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    return MATRIX(cos, sin, -sin, cos, x - x * cos + y * sin, y - x * sin - y * cos);\n  }\n  export function TRANSLATE(dX: number, dY = 0) {\n    assertNumbers(dX, dY);\n    return MATRIX(1, 0, 0, 1, dX, dY);\n  }\n  export function SCALE(dX: number, dY = dX) {\n    assertNumbers(dX, dY);\n    return MATRIX(dX, 0, 0, dY, 0, 0);\n  }\n  export function SKEW_X(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, 0, Math.atan(a), 1, 0, 0);\n  }\n  export function SKEW_Y(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, Math.atan(a), 0, 1, 0, 0);\n  }\n  export function X_AXIS_SYMMETRY(xOffset = 0) {\n    assertNumbers(xOffset);\n    return MATRIX(-1, 0, 0, 1, xOffset, 0);\n  }\n  export function Y_AXIS_SYMMETRY(yOffset = 0) {\n    assertNumbers(yOffset);\n    return MATRIX(1, 0, 0, -1, 0, yOffset);\n  }\n  // Convert arc commands to curve commands\n  export function A_TO_C() {\n    return INFO((command, prevX, prevY) => {\n      if (SVGPathData.ARC === command.type) {\n        return a2c(command, command.relative ? 0 : prevX, command.relative ? 0 : prevY);\n      }\n      return command;\n    });\n  }\n  // @see annotateArcCommand\n  export function ANNOTATE_ARCS() {\n    return INFO((c, x1, y1) => {\n      if (c.relative) {\n        x1 = 0;\n        y1 = 0;\n      }\n      if (SVGPathData.ARC === c.type) {\n        annotateArcCommand(c, x1, y1);\n      }\n      return c;\n    });\n  }\n  export function CLONE() {\n    return (c: SVGCommand) => {\n      const result = {} as SVGCommand;\n      // tslint:disable-next-line\n      for (const key in c) {\n        result[key as keyof SVGCommand] = c[key as keyof SVGCommand];\n      }\n      return result;\n    };\n  }\n  // @see annotateArcCommand\n  export function CALCULATE_BOUNDS() {\n    const clone = CLONE();\n    const toAbs = TO_ABS();\n    const qtToC = QT_TO_C();\n    const normST = NORMALIZE_ST();\n    const f: TransformFunction & {minX: number, maxX: number, minY: number, maxY: number} =\n        INFO((command, prevXAbs, prevYAbs) => {\n      const c = normST(qtToC(toAbs(clone(command))));\n      function fixX(absX: number) {\n        if (absX > f.maxX) { f.maxX = absX; }\n        if (absX < f.minX) { f.minX = absX; }\n      }\n      function fixY(absY: number) {\n        if (absY > f.maxY) { f.maxY = absY; }\n        if (absY < f.minY) { f.minY = absY; }\n      }\n      if (c.type & SVGPathData.DRAWING_COMMANDS) {\n        fixX(prevXAbs);\n        fixY(prevYAbs);\n      }\n      if (c.type & SVGPathData.HORIZ_LINE_TO) {\n        fixX(c.x);\n      }\n      if (c.type & SVGPathData.VERT_LINE_TO) {\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.LINE_TO) {\n        fixX(c.x);\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.CURVE_TO) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        const xDerivRoots = bezierRoot(prevXAbs, c.x1, c.x2, c.x);\n\n        for (const derivRoot of xDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixX(bezierAt(prevXAbs, c.x1, c.x2, c.x, derivRoot));\n          }\n        }\n        const yDerivRoots = bezierRoot(prevYAbs, c.y1, c.y2, c.y);\n\n        for (const derivRoot of yDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixY(bezierAt(prevYAbs, c.y1, c.y2, c.y, derivRoot));\n          }\n        }\n      }\n      if (c.type & SVGPathData.ARC) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        annotateArcCommand(c, prevXAbs, prevYAbs);\n        // p = cos(phi) * xv + sin(phi) * yv\n        // dp = -sin(phi) * xv + cos(phi) * yv = 0\n        const xRotRad = c.xRot / 180 * Math.PI;\n        // points on ellipse for phi = 0° and phi = 90°\n        const x0 = Math.cos(xRotRad) * c.rX;\n        const y0 = Math.sin(xRotRad) * c.rX;\n        const x90 = -Math.sin(xRotRad) * c.rY;\n        const y90 = Math.cos(xRotRad) * c.rY;\n\n        // annotateArcCommand returns phi1 and phi2 such that -180° < phi1 < 180° and phi2 is smaller or greater\n        // depending on the sweep flag. Calculate phiMin, phiMax such that -180° < phiMin < 180° and phiMin < phiMax\n        const [phiMin, phiMax] = c.phi1 < c.phi2 ?\n          [c.phi1, c.phi2] :\n          (-180 > c.phi2 ? [c.phi2 + 360, c.phi1 + 360] : [c.phi2, c.phi1]);\n        const normalizeXiEta = ([xi, eta]: [number, number]) => {\n          const phiRad = Math.atan2(eta, xi);\n          const phi = phiRad * 180 / Math.PI;\n\n          return phi < phiMin ? phi + 360 : phi;\n        };\n        // xi = cos(phi), eta = sin(phi)\n\n        const xDerivRoots = intersectionUnitCircleLine(x90, -x0, 0).map(normalizeXiEta);\n        for (const derivRoot of xDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixX(arcAt(c.cX, x0, x90, derivRoot));\n          }\n        }\n\n        const yDerivRoots = intersectionUnitCircleLine(y90, -y0, 0).map(normalizeXiEta);\n        for (const derivRoot of yDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixY(arcAt(c.cY, y0, y90, derivRoot));\n          }\n        }\n      }\n      return command;\n    }) as any;\n\n    f.minX = Infinity;\n    f.maxX = -Infinity;\n    f.minY = Infinity;\n    f.maxY = -Infinity;\n    return f;\n  }\n}\n","import { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformFunction } from \"./types\";\n\nexport abstract class TransformableSVG {\n  round(x?: number) {\n    return this.transform(SVGPathDataTransformer.ROUND(x));\n  }\n\n  toAbs() {\n    return this.transform(SVGPathDataTransformer.TO_ABS());\n  }\n\n  toRel() {\n    return this.transform(SVGPathDataTransformer.TO_REL());\n  }\n\n  normalizeHVZ(a?: boolean, b?: boolean, c?: boolean) {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_HVZ(a, b, c));\n  }\n\n  normalizeST() {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_ST());\n  }\n\n  qtToC() {\n    return this.transform(SVGPathDataTransformer.QT_TO_C());\n  }\n\n  aToC() {\n    return this.transform(SVGPathDataTransformer.A_TO_C());\n  }\n\n  sanitize(eps?: number) {\n    return this.transform(SVGPathDataTransformer.SANITIZE(eps));\n  }\n\n  translate(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.TRANSLATE(x, y));\n  }\n\n  scale(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.SCALE(x, y));\n  }\n\n  rotate(a: number, x?: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.ROTATE(a, x, y));\n  }\n\n  matrix(a: number, b: number, c: number, d: number, e: number, f: number) {\n    return this.transform(SVGPathDataTransformer.MATRIX(a, b, c, d, e, f));\n  }\n\n  skewX(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_X(a));\n  }\n\n  skewY(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_Y(a));\n  }\n\n  xSymmetry(xOffset?: number) {\n    return this.transform(SVGPathDataTransformer.X_AXIS_SYMMETRY(xOffset));\n  }\n\n  ySymmetry(yOffset?: number) {\n    return this.transform(SVGPathDataTransformer.Y_AXIS_SYMMETRY(yOffset));\n  }\n\n  annotateArcs() {\n    return this.transform(SVGPathDataTransformer.ANNOTATE_ARCS());\n  }\n\n  abstract transform(transformFunction: TransformFunction): this;\n}\n","// Parse SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\nimport { SVGPathData, COMMAND_ARG_COUNTS } from './SVGPathData';\nimport { TransformableSVG } from './TransformableSVG';\nimport { SVGCommand, TransformFunction } from './types';\n// Private consts : Char groups\nconst isWhiteSpace = (c: string) => ' ' === c || '\\t' === c || '\\r' === c || '\\n' === c;\nconst isDigit = (c: string) =>\n  '0'.charCodeAt(0) <= c.charCodeAt(0) && c.charCodeAt(0) <= '9'.charCodeAt(0);\nconst COMMANDS = 'mMzZlLhHvVcCsSqQtTaA';\n\nexport class SVGPathDataParser extends TransformableSVG {\n  private curNumber: string = '';\n  private curCommandType: SVGCommand['type'] | -1 = -1;\n  private curCommandRelative = false;\n  private canParseCommandOrComma = true;\n  private curNumberHasExp = false;\n  private curNumberHasExpDigits = false;\n  private curNumberHasDecimal = false;\n  private curArgs: number[] = [];\n\n  constructor() {\n    super();\n  }\n\n  finish(commands: SVGCommand[] = []) {\n    this.parse(' ', commands);\n    // Adding residual command\n    if (0 !== this.curArgs.length || !this.canParseCommandOrComma) {\n      throw new SyntaxError('Unterminated command at the path end.');\n    }\n    return commands;\n  }\n\n  parse(str: string, commands: SVGCommand[] = []) {\n    const finishCommand = (command: SVGCommand) => {\n      commands.push(command);\n      this.curArgs.length = 0;\n      this.canParseCommandOrComma = true;\n    };\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      // White spaces parsing\n\n      if (isDigit(c)) {\n        this.curNumber += c;\n        this.curNumberHasExpDigits = this.curNumberHasExp;\n        continue;\n      }\n      if ('e' === c || 'E' === c) {\n        this.curNumber += c;\n        this.curNumberHasExp = true;\n        continue;\n      }\n      if (('-' === c || '+' === c) && this.curNumberHasExp && !this.curNumberHasExpDigits) {\n        this.curNumber += c;\n        continue;\n      }\n      // if we already have a \".\", it means we are starting a new number\n      if ('.' === c && !this.curNumberHasExp && !this.curNumberHasDecimal) {\n        this.curNumber += c;\n        this.curNumberHasDecimal = true;\n        continue;\n      }\n\n      // New number\n      if (this.curNumber && -1 !== this.curCommandType) {\n        const val = Number(this.curNumber);\n        if (isNaN(val)) {\n          throw new SyntaxError(`Invalid number ending at ${i}`);\n        }\n        if (this.curCommandType === SVGPathData.ARC) {\n          if (0 === this.curArgs.length || 1 === this.curArgs.length) {\n            if (0 > val) {\n              throw new SyntaxError(`Expected positive number, got \"${val}\" at index \"${i}\"`);\n            }\n          } else if (3 === this.curArgs.length || 4 === this.curArgs.length) {\n            if ('0' !== this.curNumber && '1' !== this.curNumber) {\n              throw new SyntaxError(`Expected a flag, got \"${this.curNumber}\" at index \"${i}\"`);\n            }\n          }\n        }\n        this.curArgs.push(val);\n        if (this.curArgs.length === COMMAND_ARG_COUNTS[this.curCommandType]) {\n          if (SVGPathData.HORIZ_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.HORIZ_LINE_TO,\n              relative: this.curCommandRelative,\n              x: val,\n            });\n          } else if (SVGPathData.VERT_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.VERT_LINE_TO,\n              relative: this.curCommandRelative,\n              y: val,\n            });\n            // Move to / line to / smooth quadratic curve to commands (x, y)\n          } else if (\n            this.curCommandType === SVGPathData.MOVE_TO ||\n            this.curCommandType === SVGPathData.LINE_TO ||\n            this.curCommandType === SVGPathData.SMOOTH_QUAD_TO\n          ) {\n            finishCommand({\n              type: this.curCommandType,\n              relative: this.curCommandRelative,\n              x: this.curArgs[0],\n              y: this.curArgs[1],\n            } as SVGCommand);\n            // Switch to line to state\n            if (SVGPathData.MOVE_TO === this.curCommandType) {\n              this.curCommandType = SVGPathData.LINE_TO;\n            }\n          } else if (this.curCommandType === SVGPathData.CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.CURVE_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x2: this.curArgs[2],\n              y2: this.curArgs[3],\n              x: this.curArgs[4],\n              y: this.curArgs[5],\n            });\n          } else if (this.curCommandType === SVGPathData.SMOOTH_CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.SMOOTH_CURVE_TO,\n              relative: this.curCommandRelative,\n              x2: this.curArgs[0],\n              y2: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.QUAD_TO) {\n            finishCommand({\n              type: SVGPathData.QUAD_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.ARC) {\n            finishCommand({\n              type: SVGPathData.ARC,\n              relative: this.curCommandRelative,\n              rX: this.curArgs[0],\n              rY: this.curArgs[1],\n              xRot: this.curArgs[2],\n              lArcFlag: this.curArgs[3] as 0 | 1,\n              sweepFlag: this.curArgs[4] as 0 | 1,\n              x: this.curArgs[5],\n              y: this.curArgs[6],\n            });\n          }\n        }\n        this.curNumber = '';\n        this.curNumberHasExpDigits = false;\n        this.curNumberHasExp = false;\n        this.curNumberHasDecimal = false;\n        this.canParseCommandOrComma = true;\n      }\n      // Continue if a white space or a comma was detected\n      if (isWhiteSpace(c)) {\n        continue;\n      }\n      if (',' === c && this.canParseCommandOrComma) {\n        // L 0,0, H is not valid:\n        this.canParseCommandOrComma = false;\n        continue;\n      }\n      // if a sign is detected, then parse the new number\n      if ('+' === c || '-' === c || '.' === c) {\n        this.curNumber = c;\n        this.curNumberHasDecimal = '.' === c;\n        continue;\n      }\n\n      // Adding residual command\n      if (0 !== this.curArgs.length) {\n        throw new SyntaxError(`Unterminated command at index ${i}.`);\n      }\n      if (!this.canParseCommandOrComma) {\n        throw new SyntaxError(`Unexpected character \"${c}\" at index ${i}. Command cannot follow comma`);\n      }\n      this.canParseCommandOrComma = false;\n      // Detecting the next command\n      if ('z' === c || 'Z' === c) {\n        commands.push({\n          type: SVGPathData.CLOSE_PATH,\n        });\n        this.canParseCommandOrComma = true;\n        this.curCommandType = -1;\n        continue;\n        // Horizontal move to command\n      } else if ('h' === c || 'H' === c) {\n        this.curCommandType = SVGPathData.HORIZ_LINE_TO;\n        this.curCommandRelative = 'h' === c;\n        // Vertical move to command\n      } else if ('v' === c || 'V' === c) {\n        this.curCommandType = SVGPathData.VERT_LINE_TO;\n        this.curCommandRelative = 'v' === c;\n        // Move to command\n      } else if ('m' === c || 'M' === c) {\n        this.curCommandType = SVGPathData.MOVE_TO;\n        this.curCommandRelative = 'm' === c;\n        // Line to command\n      } else if ('l' === c || 'L' === c) {\n        this.curCommandType = SVGPathData.LINE_TO;\n        this.curCommandRelative = 'l' === c;\n        // Curve to command\n      } else if ('c' === c || 'C' === c) {\n        this.curCommandType = SVGPathData.CURVE_TO;\n        this.curCommandRelative = 'c' === c;\n        // Smooth curve to command\n      } else if ('s' === c || 'S' === c) {\n        this.curCommandType = SVGPathData.SMOOTH_CURVE_TO;\n        this.curCommandRelative = 's' === c;\n        // Quadratic bezier curve to command\n      } else if ('q' === c || 'Q' === c) {\n        this.curCommandType = SVGPathData.QUAD_TO;\n        this.curCommandRelative = 'q' === c;\n        // Smooth quadratic bezier curve to command\n      } else if ('t' === c || 'T' === c) {\n        this.curCommandType = SVGPathData.SMOOTH_QUAD_TO;\n        this.curCommandRelative = 't' === c;\n        // Elliptic arc command\n      } else if ('a' === c || 'A' === c) {\n        this.curCommandType = SVGPathData.ARC;\n        this.curCommandRelative = 'a' === c;\n      } else {\n        throw new SyntaxError(`Unexpected character \"${c}\" at index ${i}.`);\n      }\n    }\n    return commands;\n  }\n  /**\n   * Return a wrapper around this parser which applies the transformation on parsed commands.\n   */\n  transform(transform: TransformFunction) {\n    const result = Object.create(this, {\n      parse: {\n        value(chunk: string, commands: SVGCommand[] = []) {\n          const parsedCommands = Object.getPrototypeOf(this).parse.call(\n            this,\n            chunk,\n          );\n          for (const c of parsedCommands) {\n            const cT = transform(c);\n            if (Array.isArray(cT)) {\n              commands.push(...cT);\n            } else {\n              commands.push(cT);\n            }\n          }\n          return commands;\n        },\n      },\n    });\n    return result as this;\n  }\n}\n","import { encodeSVGPath } from \"./SVGPathDataEncoder\";\nimport { SVGPathDataParser } from \"./SVGPathDataParser\";\nimport { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand } from \"./types\";\n\nexport class SVGPathData extends TransformableSVG {\n  commands: SVGCommand[];\n  constructor(content: string | SVGCommand[]) {\n    super();\n    if (\"string\" === typeof content) {\n      this.commands = SVGPathData.parse(content);\n    } else {\n      this.commands = content;\n    }\n  }\n\n  encode() {\n    return SVGPathData.encode(this.commands);\n  }\n\n  getBounds() {\n    const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();\n\n    this.transform(boundsTransform);\n    return boundsTransform;\n  }\n\n  transform(\n    transformFunction: (input: SVGCommand) => SVGCommand | SVGCommand[],\n  ) {\n    const newCommands = [];\n\n    for (const command of this.commands) {\n      const transformedCommand = transformFunction(command);\n\n      if (Array.isArray(transformedCommand)) {\n        newCommands.push(...transformedCommand);\n      } else {\n        newCommands.push(transformedCommand);\n      }\n    }\n    this.commands = newCommands;\n    return this;\n  }\n\n  static encode(commands: SVGCommand[]) {\n    return encodeSVGPath(commands);\n      }\n\n  static parse(path: string) {\n    const parser = new SVGPathDataParser();\n    const commands: SVGCommand[] = [];\n    parser.parse(path, commands);\n    parser.finish(commands);\n    return commands;\n  }\n\n  static readonly CLOSE_PATH: 1 = 1;\n  static readonly MOVE_TO: 2 = 2;\n  static readonly HORIZ_LINE_TO: 4 = 4;\n  static readonly VERT_LINE_TO: 8 = 8;\n  static readonly LINE_TO: 16 = 16;\n  static readonly CURVE_TO: 32 = 32;\n  static readonly SMOOTH_CURVE_TO: 64 = 64;\n  static readonly QUAD_TO: 128 = 128;\n  static readonly SMOOTH_QUAD_TO: 256 = 256;\n  static readonly ARC: 512 = 512;\n  static readonly LINE_COMMANDS = SVGPathData.LINE_TO | SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO;\n  static readonly DRAWING_COMMANDS = SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO | SVGPathData.LINE_TO |\n  SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO | SVGPathData.QUAD_TO |\n  SVGPathData.SMOOTH_QUAD_TO | SVGPathData.ARC;\n}\n\nexport const COMMAND_ARG_COUNTS = {\n    [SVGPathData.MOVE_TO]: 2,\n    [SVGPathData.LINE_TO]: 2,\n    [SVGPathData.HORIZ_LINE_TO]: 1,\n    [SVGPathData.VERT_LINE_TO]: 1,\n    [SVGPathData.CLOSE_PATH]: 0,\n    [SVGPathData.QUAD_TO]: 4,\n    [SVGPathData.SMOOTH_QUAD_TO]: 2,\n    [SVGPathData.CURVE_TO]: 6,\n    [SVGPathData.SMOOTH_CURVE_TO]: 4,\n    [SVGPathData.ARC]: 7,\n};\n\nexport {encodeSVGPath} from \"./SVGPathDataEncoder\"\nexport {SVGPathDataParser} from \"./SVGPathDataParser\"\nexport {SVGPathDataTransformer} from \"./SVGPathDataTransformer\"\n","import { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand } from \"./types\";\n\n// Encode SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\n// Private consts : Char groups\nconst WSP = \" \";\n\nexport function encodeSVGPath(commands: SVGCommand | SVGCommand[]) {\n  let str = \"\";\n\n  if (!Array.isArray(commands)) {\n    commands = [commands];\n  }\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    if (command.type === SVGPathData.CLOSE_PATH) {\n      str += \"z\";\n    } else if (command.type === SVGPathData.HORIZ_LINE_TO) {\n      str += (command.relative ? \"h\" : \"H\") +\n        command.x;\n    } else if (command.type === SVGPathData.VERT_LINE_TO) {\n      str += (command.relative ? \"v\" : \"V\") +\n        command.y;\n    } else if (command.type === SVGPathData.MOVE_TO) {\n      str += (command.relative ? \"m\" : \"M\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.LINE_TO) {\n      str += (command.relative ? \"l\" : \"L\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.CURVE_TO) {\n      str += (command.relative ? \"c\" : \"C\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_CURVE_TO) {\n      str += (command.relative ? \"s\" : \"S\") +\n        command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.QUAD_TO) {\n      str += (command.relative ? \"q\" : \"Q\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_QUAD_TO) {\n      str += (command.relative ? \"t\" : \"T\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.ARC) {\n      str += (command.relative ? \"a\" : \"A\") +\n        command.rX + WSP + command.rY +\n        WSP + command.xRot +\n        WSP + (+command.lArcFlag) + WSP + (+command.sweepFlag) +\n        WSP + command.x + WSP + command.y;\n    } else {\n      // Unknown command\n      throw new Error(\n        `Unexpected command type \"${ (command as any).type}\" at index ${i}.`);\n    }\n  }\n\n  return str;\n}\n","import { encodeSVGPath } from \"./SVGPathDataEncoder\";\nimport { SVGPathDataParser } from \"./SVGPathDataParser\";\nimport { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand } from \"./types\";\n\nexport class SVGPathData extends TransformableSVG {\n  commands: SVGCommand[];\n  constructor(content: string | SVGCommand[]) {\n    super();\n    if (\"string\" === typeof content) {\n      this.commands = SVGPathData.parse(content);\n    } else {\n      this.commands = content;\n    }\n  }\n\n  encode() {\n    return SVGPathData.encode(this.commands);\n  }\n\n  getBounds() {\n    const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();\n\n    this.transform(boundsTransform);\n    return boundsTransform;\n  }\n\n  transform(\n    transformFunction: (input: SVGCommand) => SVGCommand | SVGCommand[],\n  ) {\n    const newCommands = [];\n\n    for (const command of this.commands) {\n      const transformedCommand = transformFunction(command);\n\n      if (Array.isArray(transformedCommand)) {\n        newCommands.push(...transformedCommand);\n      } else {\n        newCommands.push(transformedCommand);\n      }\n    }\n    this.commands = newCommands;\n    return this;\n  }\n\n  static encode(commands: SVGCommand[]) {\n    return encodeSVGPath(commands);\n      }\n\n  static parse(path: string) {\n    const parser = new SVGPathDataParser();\n    const commands: SVGCommand[] = [];\n    parser.parse(path, commands);\n    parser.finish(commands);\n    return commands;\n  }\n\n  static readonly CLOSE_PATH: 1 = 1;\n  static readonly MOVE_TO: 2 = 2;\n  static readonly HORIZ_LINE_TO: 4 = 4;\n  static readonly VERT_LINE_TO: 8 = 8;\n  static readonly LINE_TO: 16 = 16;\n  static readonly CURVE_TO: 32 = 32;\n  static readonly SMOOTH_CURVE_TO: 64 = 64;\n  static readonly QUAD_TO: 128 = 128;\n  static readonly SMOOTH_QUAD_TO: 256 = 256;\n  static readonly ARC: 512 = 512;\n  static readonly LINE_COMMANDS = SVGPathData.LINE_TO | SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO;\n  static readonly DRAWING_COMMANDS = SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO | SVGPathData.LINE_TO |\n  SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO | SVGPathData.QUAD_TO |\n  SVGPathData.SMOOTH_QUAD_TO | SVGPathData.ARC;\n}\n\nexport const COMMAND_ARG_COUNTS = {\n    [SVGPathData.MOVE_TO]: 2,\n    [SVGPathData.LINE_TO]: 2,\n    [SVGPathData.HORIZ_LINE_TO]: 1,\n    [SVGPathData.VERT_LINE_TO]: 1,\n    [SVGPathData.CLOSE_PATH]: 0,\n    [SVGPathData.QUAD_TO]: 4,\n    [SVGPathData.SMOOTH_QUAD_TO]: 2,\n    [SVGPathData.CURVE_TO]: 6,\n    [SVGPathData.SMOOTH_CURVE_TO]: 4,\n    [SVGPathData.ARC]: 7,\n};\n\nexport {encodeSVGPath} from \"./SVGPathDataEncoder\"\nexport {SVGPathDataParser} from \"./SVGPathDataParser\"\nexport {SVGPathDataTransformer} from \"./SVGPathDataTransformer\"\n"],"names":["_a","rad","x","y","Math","cos","sin","_i","numbers","i","length","Error","PI","c","x1","y1","lArcFlag","sweepFlag","rX","rY","abs","x1_","y1_","testValue","pow","sqrt","c_ScaleTemp","c_Scale","max","cx_","cy_","cRot","rotate","xRot","cX","cY","phi1","atan2","phi2","a","b","assertNumbers","termSqr","term","SVGPathDataTransformer","DEG","t","x2","phiDeg","x0","x3","x01","x12","pqFormula","s","p","q","PRECISION","discriminantX4","root","arc","y0","annotateArcCommand","phiMin","min","deltaPhi","partCount","ceil","result","Array","prevX","prevY","phiStart","lerp","phiEnd","deltaPhi_1","f","tan","_e","_f","_g","y2","relative","type","SVGPathData","CURVE_TO","transform","xTemp","yTemp","_b","_c","_d","INFO","command","prevCurveC2X","NaN","prevCurveC2Y","prevQuadCX","prevQuadCY","SMOOTH_CURVE_TO","isNaN","SMOOTH_QUAD_TO","QUAD_TO","prevQuadX1","prevQuadY1","prevXAbs","prevYAbs","pathStartXAbs","pathStartYAbs","MOVE_TO","CLOSE_PATH","d","e","pathStartX","origX1","origX2","comRel","HORIZ_LINE_TO","LINE_TO","VERT_LINE_TO","det","sinRot","cosRot","xCurve","sqr","yCurve","A","B","C","A1","B1","C1","newXRot","newSinRot","newCosRot","key","roundVal","val","round","rf","normalizeZ","normalizeH","normalizeV","pathStartY","ARC","EPS","skip","x1Rel","y1Rel","LINE_COMMANDS","xRel","yRel","x2Rel","y2Rel","MATRIX","dX","dY","atan","xOffset","yOffset","a2c","clone","toAbs","TO_ABS","qtToC","QT_TO_C","normST","NORMALIZE_ST","absX","maxX","minX","absY","maxY","minY","DRAWING_COMMANDS","fixX","fixY","xDerivRoots_1","bezierRoot","derivRoot","bezierAt","yDerivRoots_1","xRotRad","x90","y90","phiMin_1","phiMax","normalizeXiEta","xi","eta","phi","xDerivRoots_2","intersectionUnitCircleLine","map","arcAt","yDerivRoots_2","Infinity","TransformableSVG","this","ROUND","TO_REL","NORMALIZE_HVZ","A_TO_C","eps","SANITIZE","TRANSLATE","SCALE","ROTATE","SKEW_X","SKEW_Y","X_AXIS_SYMMETRY","Y_AXIS_SYMMETRY","ANNOTATE_ARCS","isWhiteSpace","isDigit","charCodeAt","_super","_this","tslib_1.__extends","SVGPathDataParser","commands","parse","curArgs","canParseCommandOrComma","SyntaxError","str","finishCommand","push","curNumber","curNumberHasExpDigits","curNumberHasExp","curNumberHasDecimal","curCommandType","Number","COMMAND_ARG_COUNTS","curCommandRelative","Object","create","value","chunk","parsedCommands_1","getPrototypeOf","call","cT","isArray","content","encode","boundsTransform","CALCULATE_BOUNDS","transformFunction","newCommands","transformedCommand","encodeSVGPath","path","parser","finish","WSP"],"mappings":"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"}