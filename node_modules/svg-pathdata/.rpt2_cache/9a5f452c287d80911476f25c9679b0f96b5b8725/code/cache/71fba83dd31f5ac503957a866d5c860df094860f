{"code":"// Transform SVG PathData\r\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\r\nimport { a2c, annotateArcCommand, arcAt, assertNumbers, bezierAt, bezierRoot, intersectionUnitCircleLine } from \"./mathUtils\";\r\nimport { SVGPathData } from \"./SVGPathData\";\r\nexport var SVGPathDataTransformer;\r\n(function (SVGPathDataTransformer) {\r\n    // Predefined transforming functions\r\n    // Rounds commands values\r\n    function ROUND(roundVal) {\r\n        if (roundVal === void 0) { roundVal = 1e13; }\r\n        assertNumbers(roundVal);\r\n        function rf(val) { return Math.round(val * roundVal) / roundVal; }\r\n        return function round(command) {\r\n            if (\"undefined\" !== typeof command.x1) {\r\n                command.x1 = rf(command.x1);\r\n            }\r\n            if (\"undefined\" !== typeof command.y1) {\r\n                command.y1 = rf(command.y1);\r\n            }\r\n            if (\"undefined\" !== typeof command.x2) {\r\n                command.x2 = rf(command.x2);\r\n            }\r\n            if (\"undefined\" !== typeof command.y2) {\r\n                command.y2 = rf(command.y2);\r\n            }\r\n            if (\"undefined\" !== typeof command.x) {\r\n                command.x = rf(command.x);\r\n            }\r\n            if (\"undefined\" !== typeof command.y) {\r\n                command.y = rf(command.y);\r\n            }\r\n            return command;\r\n        };\r\n    }\r\n    SVGPathDataTransformer.ROUND = ROUND;\r\n    // Relative to absolute commands\r\n    function TO_ABS() {\r\n        return INFO(function (command, prevX, prevY) {\r\n            if (command.relative) {\r\n                // x1/y1 values\r\n                if (\"undefined\" !== typeof command.x1) {\r\n                    command.x1 += prevX;\r\n                }\r\n                if (\"undefined\" !== typeof command.y1) {\r\n                    command.y1 += prevY;\r\n                }\r\n                // x2/y2 values\r\n                if (\"undefined\" !== typeof command.x2) {\r\n                    command.x2 += prevX;\r\n                }\r\n                if (\"undefined\" !== typeof command.y2) {\r\n                    command.y2 += prevY;\r\n                }\r\n                // Finally x/y values\r\n                if (\"undefined\" !== typeof command.x) {\r\n                    command.x += prevX;\r\n                }\r\n                if (\"undefined\" !== typeof command.y) {\r\n                    command.y += prevY;\r\n                }\r\n                command.relative = false;\r\n            }\r\n            return command;\r\n        });\r\n    }\r\n    SVGPathDataTransformer.TO_ABS = TO_ABS;\r\n    // Absolute to relative commands\r\n    function TO_REL() {\r\n        return INFO(function (command, prevX, prevY) {\r\n            if (!command.relative) {\r\n                // x1/y1 values\r\n                if (\"undefined\" !== typeof command.x1) {\r\n                    command.x1 -= prevX;\r\n                }\r\n                if (\"undefined\" !== typeof command.y1) {\r\n                    command.y1 -= prevY;\r\n                }\r\n                // x2/y2 values\r\n                if (\"undefined\" !== typeof command.x2) {\r\n                    command.x2 -= prevX;\r\n                }\r\n                if (\"undefined\" !== typeof command.y2) {\r\n                    command.y2 -= prevY;\r\n                }\r\n                // Finally x/y values\r\n                if (\"undefined\" !== typeof command.x) {\r\n                    command.x -= prevX;\r\n                }\r\n                if (\"undefined\" !== typeof command.y) {\r\n                    command.y -= prevY;\r\n                }\r\n                command.relative = true;\r\n            }\r\n            return command;\r\n        });\r\n    }\r\n    SVGPathDataTransformer.TO_REL = TO_REL;\r\n    // Convert H, V, Z and A with rX = 0 to L\r\n    function NORMALIZE_HVZ(normalizeZ, normalizeH, normalizeV) {\r\n        if (normalizeZ === void 0) { normalizeZ = true; }\r\n        if (normalizeH === void 0) { normalizeH = true; }\r\n        if (normalizeV === void 0) { normalizeV = true; }\r\n        return INFO(function (command, prevX, prevY, pathStartX, pathStartY) {\r\n            if (isNaN(pathStartX) && !(command.type & SVGPathData.MOVE_TO)) {\r\n                throw new Error(\"path must start with moveto\");\r\n            }\r\n            if (normalizeH && command.type & SVGPathData.HORIZ_LINE_TO) {\r\n                command.type = SVGPathData.LINE_TO;\r\n                command.y = command.relative ? 0 : prevY;\r\n            }\r\n            if (normalizeV && command.type & SVGPathData.VERT_LINE_TO) {\r\n                command.type = SVGPathData.LINE_TO;\r\n                command.x = command.relative ? 0 : prevX;\r\n            }\r\n            if (normalizeZ && command.type & SVGPathData.CLOSE_PATH) {\r\n                command.type = SVGPathData.LINE_TO;\r\n                command.x = command.relative ? pathStartX - prevX : pathStartX;\r\n                command.y = command.relative ? pathStartY - prevY : pathStartY;\r\n            }\r\n            if (command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY)) {\r\n                command.type = SVGPathData.LINE_TO;\r\n                delete command.rX;\r\n                delete command.rY;\r\n                delete command.xRot;\r\n                delete command.lArcFlag;\r\n                delete command.sweepFlag;\r\n            }\r\n            return command;\r\n        });\r\n    }\r\n    SVGPathDataTransformer.NORMALIZE_HVZ = NORMALIZE_HVZ;\r\n    /*\r\n     * Transforms smooth curves and quads to normal curves and quads (SsTt to CcQq)\r\n     */\r\n    function NORMALIZE_ST() {\r\n        var prevCurveC2X = NaN;\r\n        var prevCurveC2Y = NaN;\r\n        var prevQuadCX = NaN;\r\n        var prevQuadCY = NaN;\r\n        return INFO(function (command, prevX, prevY) {\r\n            if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\r\n                command.type = SVGPathData.CURVE_TO;\r\n                prevCurveC2X = isNaN(prevCurveC2X) ? prevX : prevCurveC2X;\r\n                prevCurveC2Y = isNaN(prevCurveC2Y) ? prevY : prevCurveC2Y;\r\n                command.x1 = command.relative ? prevX - prevCurveC2X : 2 * prevX - prevCurveC2X;\r\n                command.y1 = command.relative ? prevY - prevCurveC2Y : 2 * prevY - prevCurveC2Y;\r\n            }\r\n            if (command.type & SVGPathData.CURVE_TO) {\r\n                prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\r\n                prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\r\n            }\r\n            else {\r\n                prevCurveC2X = NaN;\r\n                prevCurveC2Y = NaN;\r\n            }\r\n            if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\r\n                command.type = SVGPathData.QUAD_TO;\r\n                prevQuadCX = isNaN(prevQuadCX) ? prevX : prevQuadCX;\r\n                prevQuadCY = isNaN(prevQuadCY) ? prevY : prevQuadCY;\r\n                command.x1 = command.relative ? prevX - prevQuadCX : 2 * prevX - prevQuadCX;\r\n                command.y1 = command.relative ? prevY - prevQuadCY : 2 * prevY - prevQuadCY;\r\n            }\r\n            if (command.type & SVGPathData.QUAD_TO) {\r\n                prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\r\n                prevQuadCY = command.relative ? prevY + command.y1 : command.y1;\r\n            }\r\n            else {\r\n                prevQuadCX = NaN;\r\n                prevQuadCY = NaN;\r\n            }\r\n            return command;\r\n        });\r\n    }\r\n    SVGPathDataTransformer.NORMALIZE_ST = NORMALIZE_ST;\r\n    /*\r\n     * A quadratic bézier curve can be represented by a cubic bézier curve which has\r\n     * the same end points as the quadratic and both control points in place of the\r\n     * quadratic\"s one.\r\n     *\r\n     * This transformer replaces QqTt commands with Cc commands respectively.\r\n     * This is useful for reading path data into a system which only has a\r\n     * representation for cubic curves.\r\n     */\r\n    function QT_TO_C() {\r\n        var prevQuadX1 = NaN;\r\n        var prevQuadY1 = NaN;\r\n        return INFO(function (command, prevX, prevY) {\r\n            if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\r\n                command.type = SVGPathData.QUAD_TO;\r\n                prevQuadX1 = isNaN(prevQuadX1) ? prevX : prevQuadX1;\r\n                prevQuadY1 = isNaN(prevQuadY1) ? prevY : prevQuadY1;\r\n                command.x1 = command.relative ? prevX - prevQuadX1 : 2 * prevX - prevQuadX1;\r\n                command.y1 = command.relative ? prevY - prevQuadY1 : 2 * prevY - prevQuadY1;\r\n            }\r\n            if (command.type & SVGPathData.QUAD_TO) {\r\n                prevQuadX1 = command.relative ? prevX + command.x1 : command.x1;\r\n                prevQuadY1 = command.relative ? prevY + command.y1 : command.y1;\r\n                var x1 = command.x1;\r\n                var y1 = command.y1;\r\n                command.type = SVGPathData.CURVE_TO;\r\n                command.x1 = ((command.relative ? 0 : prevX) + x1 * 2) / 3;\r\n                command.y1 = ((command.relative ? 0 : prevY) + y1 * 2) / 3;\r\n                command.x2 = (command.x + x1 * 2) / 3;\r\n                command.y2 = (command.y + y1 * 2) / 3;\r\n            }\r\n            else {\r\n                prevQuadX1 = NaN;\r\n                prevQuadY1 = NaN;\r\n            }\r\n            return command;\r\n        });\r\n    }\r\n    SVGPathDataTransformer.QT_TO_C = QT_TO_C;\r\n    function INFO(f) {\r\n        var prevXAbs = 0;\r\n        var prevYAbs = 0;\r\n        var pathStartXAbs = NaN;\r\n        var pathStartYAbs = NaN;\r\n        return function transform(command) {\r\n            if (isNaN(pathStartXAbs) && !(command.type & SVGPathData.MOVE_TO)) {\r\n                throw new Error(\"path must start with moveto\");\r\n            }\r\n            var result = f(command, prevXAbs, prevYAbs, pathStartXAbs, pathStartYAbs);\r\n            if (command.type & SVGPathData.CLOSE_PATH) {\r\n                prevXAbs = pathStartXAbs;\r\n                prevYAbs = pathStartYAbs;\r\n            }\r\n            if (\"undefined\" !== typeof command.x) {\r\n                prevXAbs = (command.relative ? prevXAbs + command.x : command.x);\r\n            }\r\n            if (\"undefined\" !== typeof command.y) {\r\n                prevYAbs = (command.relative ? prevYAbs + command.y : command.y);\r\n            }\r\n            if (command.type & SVGPathData.MOVE_TO) {\r\n                pathStartXAbs = prevXAbs;\r\n                pathStartYAbs = prevYAbs;\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    SVGPathDataTransformer.INFO = INFO;\r\n    /*\r\n     * remove 0-length segments\r\n     */\r\n    function SANITIZE(EPS) {\r\n        if (EPS === void 0) { EPS = 0; }\r\n        assertNumbers(EPS);\r\n        var prevCurveC2X = NaN;\r\n        var prevCurveC2Y = NaN;\r\n        var prevQuadCX = NaN;\r\n        var prevQuadCY = NaN;\r\n        return INFO(function (command, prevX, prevY, pathStartX, pathStartY) {\r\n            var abs = Math.abs;\r\n            var skip = false;\r\n            var x1Rel = 0;\r\n            var y1Rel = 0;\r\n            if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\r\n                x1Rel = isNaN(prevCurveC2X) ? 0 : prevX - prevCurveC2X;\r\n                y1Rel = isNaN(prevCurveC2Y) ? 0 : prevY - prevCurveC2Y;\r\n            }\r\n            if (command.type & (SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO)) {\r\n                prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\r\n                prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\r\n            }\r\n            else {\r\n                prevCurveC2X = NaN;\r\n                prevCurveC2Y = NaN;\r\n            }\r\n            if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\r\n                prevQuadCX = isNaN(prevQuadCX) ? prevX : 2 * prevX - prevQuadCX;\r\n                prevQuadCY = isNaN(prevQuadCY) ? prevY : 2 * prevY - prevQuadCY;\r\n            }\r\n            else if (command.type & SVGPathData.QUAD_TO) {\r\n                prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\r\n                prevQuadCY = command.relative ? prevY + command.y1 : command.y2;\r\n            }\r\n            else {\r\n                prevQuadCX = NaN;\r\n                prevQuadCY = NaN;\r\n            }\r\n            if (command.type & SVGPathData.LINE_COMMANDS ||\r\n                command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY || !command.lArcFlag) ||\r\n                command.type & SVGPathData.CURVE_TO || command.type & SVGPathData.SMOOTH_CURVE_TO ||\r\n                command.type & SVGPathData.QUAD_TO || command.type & SVGPathData.SMOOTH_QUAD_TO) {\r\n                var xRel = \"undefined\" === typeof command.x ? 0 :\r\n                    (command.relative ? command.x : command.x - prevX);\r\n                var yRel = \"undefined\" === typeof command.y ? 0 :\r\n                    (command.relative ? command.y : command.y - prevY);\r\n                x1Rel = !isNaN(prevQuadCX) ? prevQuadCX - prevX :\r\n                    \"undefined\" === typeof command.x1 ? x1Rel :\r\n                        command.relative ? command.x :\r\n                            command.x1 - prevX;\r\n                y1Rel = !isNaN(prevQuadCY) ? prevQuadCY - prevY :\r\n                    \"undefined\" === typeof command.y1 ? y1Rel :\r\n                        command.relative ? command.y :\r\n                            command.y1 - prevY;\r\n                var x2Rel = \"undefined\" === typeof command.x2 ? 0 :\r\n                    (command.relative ? command.x : command.x2 - prevX);\r\n                var y2Rel = \"undefined\" === typeof command.y2 ? 0 :\r\n                    (command.relative ? command.y : command.y2 - prevY);\r\n                if (abs(xRel) <= EPS && abs(yRel) <= EPS &&\r\n                    abs(x1Rel) <= EPS && abs(y1Rel) <= EPS &&\r\n                    abs(x2Rel) <= EPS && abs(y2Rel) <= EPS) {\r\n                    skip = true;\r\n                }\r\n            }\r\n            if (command.type & SVGPathData.CLOSE_PATH) {\r\n                if (abs(prevX - pathStartX) <= EPS && abs(prevY - pathStartY) <= EPS) {\r\n                    skip = true;\r\n                }\r\n            }\r\n            return skip ? [] : command;\r\n        });\r\n    }\r\n    SVGPathDataTransformer.SANITIZE = SANITIZE;\r\n    // SVG Transforms : http://www.w3.org/TR/SVGTiny12/coords.html#TransformList\r\n    // Matrix : http://apike.ca/prog_svg_transform.html\r\n    // a c e\r\n    // b d f\r\n    function MATRIX(a, b, c, d, e, f) {\r\n        assertNumbers(a, b, c, d, e, f);\r\n        return INFO(function (command, prevX, prevY, pathStartX) {\r\n            var origX1 = command.x1;\r\n            var origX2 = command.x2;\r\n            // if isNaN(pathStartX), then this is the first command, which is ALWAYS an\r\n            // absolute MOVE_TO, regardless what the relative flag says\r\n            var comRel = command.relative && !isNaN(pathStartX);\r\n            var x = \"undefined\" !== typeof command.x ? command.x : (comRel ? 0 : prevX);\r\n            var y = \"undefined\" !== typeof command.y ? command.y : (comRel ? 0 : prevY);\r\n            if (command.type & SVGPathData.HORIZ_LINE_TO && 0 !== b) {\r\n                command.type = SVGPathData.LINE_TO;\r\n                command.y = command.relative ? 0 : prevY;\r\n            }\r\n            if (command.type & SVGPathData.VERT_LINE_TO && 0 !== c) {\r\n                command.type = SVGPathData.LINE_TO;\r\n                command.x = command.relative ? 0 : prevX;\r\n            }\r\n            if (\"undefined\" !== typeof command.x) {\r\n                command.x = (command.x * a) + (y * c) + (comRel ? 0 : e);\r\n            }\r\n            if (\"undefined\" !== typeof command.y) {\r\n                command.y = (x * b) + command.y * d + (comRel ? 0 : f);\r\n            }\r\n            if (\"undefined\" !== typeof command.x1) {\r\n                command.x1 = command.x1 * a + command.y1 * c + (comRel ? 0 : e);\r\n            }\r\n            if (\"undefined\" !== typeof command.y1) {\r\n                command.y1 = origX1 * b + command.y1 * d + (comRel ? 0 : f);\r\n            }\r\n            if (\"undefined\" !== typeof command.x2) {\r\n                command.x2 = command.x2 * a + command.y2 * c + (comRel ? 0 : e);\r\n            }\r\n            if (\"undefined\" !== typeof command.y2) {\r\n                command.y2 = origX2 * b + command.y2 * d + (comRel ? 0 : f);\r\n            }\r\n            function sqr(x) { return x * x; }\r\n            var det = a * d - b * c;\r\n            if (\"undefined\" !== typeof command.xRot) {\r\n                // Skip if this is a pure translation\r\n                if (1 !== a || 0 !== b || 0 !== c || 1 !== d) {\r\n                    // Special case for singular matrix\r\n                    if (0 === det) {\r\n                        // In the singular case, the arc is compressed to a line. The actual geometric image of the original\r\n                        // curve under this transform possibly extends beyond the starting and/or ending points of the segment, but\r\n                        // for simplicity we ignore this detail and just replace this command with a single line segment.\r\n                        delete command.rX;\r\n                        delete command.rY;\r\n                        delete command.xRot;\r\n                        delete command.lArcFlag;\r\n                        delete command.sweepFlag;\r\n                        command.type = SVGPathData.LINE_TO;\r\n                    }\r\n                    else {\r\n                        // Convert to radians\r\n                        var xRot = command.xRot * Math.PI / 180;\r\n                        // Convert rotated ellipse to general conic form\r\n                        // x0^2/rX^2 + y0^2/rY^2 - 1 = 0\r\n                        // x0 = x*cos(xRot) + y*sin(xRot)\r\n                        // y0 = -x*sin(xRot) + y*cos(xRot)\r\n                        // --> A*x^2 + B*x*y + C*y^2 - 1 = 0, where\r\n                        var sinRot = Math.sin(xRot);\r\n                        var cosRot = Math.cos(xRot);\r\n                        var xCurve = 1 / sqr(command.rX);\r\n                        var yCurve = 1 / sqr(command.rY);\r\n                        var A = sqr(cosRot) * xCurve + sqr(sinRot) * yCurve;\r\n                        var B = 2 * sinRot * cosRot * (xCurve - yCurve);\r\n                        var C = sqr(sinRot) * xCurve + sqr(cosRot) * yCurve;\r\n                        // Apply matrix to A*x^2 + B*x*y + C*y^2 - 1 = 0\r\n                        // x1 = a*x + c*y\r\n                        // y1 = b*x + d*y\r\n                        //      (we can ignore e and f, since pure translations don\"t affect the shape of the ellipse)\r\n                        // --> A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 = 0, where\r\n                        var A1 = A * d * d - B * b * d + C * b * b;\r\n                        var B1 = B * (a * d + b * c) - 2 * (A * c * d + C * a * b);\r\n                        var C1 = A * c * c - B * a * c + C * a * a;\r\n                        // Unapply newXRot to get back to axis-aligned ellipse equation\r\n                        // x1 = x2*cos(newXRot) - y2*sin(newXRot)\r\n                        // y1 = x2*sin(newXRot) + y2*cos(newXRot)\r\n                        // A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 =\r\n                        //   x2^2*(A1*cos(newXRot)^2 + B1*sin(newXRot)*cos(newXRot) + C1*sin(newXRot)^2)\r\n                        //   + x2*y2*(2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2))\r\n                        //   + y2^2*(A1*sin(newXRot)^2 - B1*sin(newXRot)*cos(newXRot) + C1*cos(newXRot)^2)\r\n                        //   (which must have the same zeroes as)\r\n                        // x2^2/newRX^2 + y2^2/newRY^2 - 1\r\n                        //   (so we have)\r\n                        // 2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2) = 0\r\n                        // (A1 - C1)*sin(2*newXRot) = B1*cos(2*newXRot)\r\n                        // 2*newXRot = atan2(B1, A1 - C1)\r\n                        var newXRot = ((Math.atan2(B1, A1 - C1) + Math.PI) % Math.PI) / 2;\r\n                        // For any integer n, (atan2(B1, A1 - C1) + n*pi)/2 is a solution to the above; incrementing n just swaps\r\n                        // the x and y radii computed below (since that\"s what rotating an ellipse by pi/2 does).  Choosing the\r\n                        // rotation between 0 and pi/2 eliminates the ambiguity and leads to more predictable output.\r\n                        // Finally, we get newRX and newRY from the same-zeroes relationship that gave us newXRot\r\n                        var newSinRot = Math.sin(newXRot);\r\n                        var newCosRot = Math.cos(newXRot);\r\n                        command.rX = Math.abs(det) /\r\n                            Math.sqrt(A1 * sqr(newCosRot) + B1 * newSinRot * newCosRot + C1 * sqr(newSinRot));\r\n                        command.rY = Math.abs(det) /\r\n                            Math.sqrt(A1 * sqr(newSinRot) - B1 * newSinRot * newCosRot + C1 * sqr(newCosRot));\r\n                        command.xRot = newXRot * 180 / Math.PI;\r\n                    }\r\n                }\r\n            }\r\n            // sweepFlag needs to be inverted when mirroring shapes\r\n            // see http://www.itk.ilstu.edu/faculty/javila/SVG/SVG_drawing1/elliptical_curve.htm\r\n            // m 65,10 a 50,25 0 1 0 50,25\r\n            // M 65,60 A 50,25 0 1 1 115,35\r\n            if (\"undefined\" !== typeof command.sweepFlag && 0 > det) {\r\n                command.sweepFlag = +!command.sweepFlag;\r\n            }\r\n            return command;\r\n        });\r\n    }\r\n    SVGPathDataTransformer.MATRIX = MATRIX;\r\n    function ROTATE(a, x, y) {\r\n        if (x === void 0) { x = 0; }\r\n        if (y === void 0) { y = 0; }\r\n        assertNumbers(a, x, y);\r\n        var sin = Math.sin(a);\r\n        var cos = Math.cos(a);\r\n        return MATRIX(cos, sin, -sin, cos, x - x * cos + y * sin, y - x * sin - y * cos);\r\n    }\r\n    SVGPathDataTransformer.ROTATE = ROTATE;\r\n    function TRANSLATE(dX, dY) {\r\n        if (dY === void 0) { dY = 0; }\r\n        assertNumbers(dX, dY);\r\n        return MATRIX(1, 0, 0, 1, dX, dY);\r\n    }\r\n    SVGPathDataTransformer.TRANSLATE = TRANSLATE;\r\n    function SCALE(dX, dY) {\r\n        if (dY === void 0) { dY = dX; }\r\n        assertNumbers(dX, dY);\r\n        return MATRIX(dX, 0, 0, dY, 0, 0);\r\n    }\r\n    SVGPathDataTransformer.SCALE = SCALE;\r\n    function SKEW_X(a) {\r\n        assertNumbers(a);\r\n        return MATRIX(1, 0, Math.atan(a), 1, 0, 0);\r\n    }\r\n    SVGPathDataTransformer.SKEW_X = SKEW_X;\r\n    function SKEW_Y(a) {\r\n        assertNumbers(a);\r\n        return MATRIX(1, Math.atan(a), 0, 1, 0, 0);\r\n    }\r\n    SVGPathDataTransformer.SKEW_Y = SKEW_Y;\r\n    function X_AXIS_SYMMETRY(xOffset) {\r\n        if (xOffset === void 0) { xOffset = 0; }\r\n        assertNumbers(xOffset);\r\n        return MATRIX(-1, 0, 0, 1, xOffset, 0);\r\n    }\r\n    SVGPathDataTransformer.X_AXIS_SYMMETRY = X_AXIS_SYMMETRY;\r\n    function Y_AXIS_SYMMETRY(yOffset) {\r\n        if (yOffset === void 0) { yOffset = 0; }\r\n        assertNumbers(yOffset);\r\n        return MATRIX(1, 0, 0, -1, 0, yOffset);\r\n    }\r\n    SVGPathDataTransformer.Y_AXIS_SYMMETRY = Y_AXIS_SYMMETRY;\r\n    // Convert arc commands to curve commands\r\n    function A_TO_C() {\r\n        return INFO(function (command, prevX, prevY) {\r\n            if (SVGPathData.ARC === command.type) {\r\n                return a2c(command, command.relative ? 0 : prevX, command.relative ? 0 : prevY);\r\n            }\r\n            return command;\r\n        });\r\n    }\r\n    SVGPathDataTransformer.A_TO_C = A_TO_C;\r\n    // @see annotateArcCommand\r\n    function ANNOTATE_ARCS() {\r\n        return INFO(function (c, x1, y1) {\r\n            if (c.relative) {\r\n                x1 = 0;\r\n                y1 = 0;\r\n            }\r\n            if (SVGPathData.ARC === c.type) {\r\n                annotateArcCommand(c, x1, y1);\r\n            }\r\n            return c;\r\n        });\r\n    }\r\n    SVGPathDataTransformer.ANNOTATE_ARCS = ANNOTATE_ARCS;\r\n    function CLONE() {\r\n        return function (c) {\r\n            var result = {};\r\n            // tslint:disable-next-line\r\n            for (var key in c) {\r\n                result[key] = c[key];\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    SVGPathDataTransformer.CLONE = CLONE;\r\n    // @see annotateArcCommand\r\n    function CALCULATE_BOUNDS() {\r\n        var clone = CLONE();\r\n        var toAbs = TO_ABS();\r\n        var qtToC = QT_TO_C();\r\n        var normST = NORMALIZE_ST();\r\n        var f = INFO(function (command, prevXAbs, prevYAbs) {\r\n            var c = normST(qtToC(toAbs(clone(command))));\r\n            function fixX(absX) {\r\n                if (absX > f.maxX) {\r\n                    f.maxX = absX;\r\n                }\r\n                if (absX < f.minX) {\r\n                    f.minX = absX;\r\n                }\r\n            }\r\n            function fixY(absY) {\r\n                if (absY > f.maxY) {\r\n                    f.maxY = absY;\r\n                }\r\n                if (absY < f.minY) {\r\n                    f.minY = absY;\r\n                }\r\n            }\r\n            if (c.type & SVGPathData.DRAWING_COMMANDS) {\r\n                fixX(prevXAbs);\r\n                fixY(prevYAbs);\r\n            }\r\n            if (c.type & SVGPathData.HORIZ_LINE_TO) {\r\n                fixX(c.x);\r\n            }\r\n            if (c.type & SVGPathData.VERT_LINE_TO) {\r\n                fixY(c.y);\r\n            }\r\n            if (c.type & SVGPathData.LINE_TO) {\r\n                fixX(c.x);\r\n                fixY(c.y);\r\n            }\r\n            if (c.type & SVGPathData.CURVE_TO) {\r\n                // add start and end points\r\n                fixX(c.x);\r\n                fixY(c.y);\r\n                var xDerivRoots = bezierRoot(prevXAbs, c.x1, c.x2, c.x);\r\n                for (var _i = 0, xDerivRoots_1 = xDerivRoots; _i < xDerivRoots_1.length; _i++) {\r\n                    var derivRoot = xDerivRoots_1[_i];\r\n                    if (0 < derivRoot && 1 > derivRoot) {\r\n                        fixX(bezierAt(prevXAbs, c.x1, c.x2, c.x, derivRoot));\r\n                    }\r\n                }\r\n                var yDerivRoots = bezierRoot(prevYAbs, c.y1, c.y2, c.y);\r\n                for (var _a = 0, yDerivRoots_1 = yDerivRoots; _a < yDerivRoots_1.length; _a++) {\r\n                    var derivRoot = yDerivRoots_1[_a];\r\n                    if (0 < derivRoot && 1 > derivRoot) {\r\n                        fixY(bezierAt(prevYAbs, c.y1, c.y2, c.y, derivRoot));\r\n                    }\r\n                }\r\n            }\r\n            if (c.type & SVGPathData.ARC) {\r\n                // add start and end points\r\n                fixX(c.x);\r\n                fixY(c.y);\r\n                annotateArcCommand(c, prevXAbs, prevYAbs);\r\n                // p = cos(phi) * xv + sin(phi) * yv\r\n                // dp = -sin(phi) * xv + cos(phi) * yv = 0\r\n                var xRotRad = c.xRot / 180 * Math.PI;\r\n                // points on ellipse for phi = 0° and phi = 90°\r\n                var x0 = Math.cos(xRotRad) * c.rX;\r\n                var y0 = Math.sin(xRotRad) * c.rX;\r\n                var x90 = -Math.sin(xRotRad) * c.rY;\r\n                var y90 = Math.cos(xRotRad) * c.rY;\r\n                // annotateArcCommand returns phi1 and phi2 such that -180° < phi1 < 180° and phi2 is smaller or greater\r\n                // depending on the sweep flag. Calculate phiMin, phiMax such that -180° < phiMin < 180° and phiMin < phiMax\r\n                var _b = c.phi1 < c.phi2 ?\r\n                    [c.phi1, c.phi2] :\r\n                    (-180 > c.phi2 ? [c.phi2 + 360, c.phi1 + 360] : [c.phi2, c.phi1]), phiMin_1 = _b[0], phiMax = _b[1];\r\n                var normalizeXiEta = function (_a) {\r\n                    var xi = _a[0], eta = _a[1];\r\n                    var phiRad = Math.atan2(eta, xi);\r\n                    var phi = phiRad * 180 / Math.PI;\r\n                    return phi < phiMin_1 ? phi + 360 : phi;\r\n                };\r\n                // xi = cos(phi), eta = sin(phi)\r\n                var xDerivRoots = intersectionUnitCircleLine(x90, -x0, 0).map(normalizeXiEta);\r\n                for (var _c = 0, xDerivRoots_2 = xDerivRoots; _c < xDerivRoots_2.length; _c++) {\r\n                    var derivRoot = xDerivRoots_2[_c];\r\n                    if (derivRoot > phiMin_1 && derivRoot < phiMax) {\r\n                        fixX(arcAt(c.cX, x0, x90, derivRoot));\r\n                    }\r\n                }\r\n                var yDerivRoots = intersectionUnitCircleLine(y90, -y0, 0).map(normalizeXiEta);\r\n                for (var _d = 0, yDerivRoots_2 = yDerivRoots; _d < yDerivRoots_2.length; _d++) {\r\n                    var derivRoot = yDerivRoots_2[_d];\r\n                    if (derivRoot > phiMin_1 && derivRoot < phiMax) {\r\n                        fixY(arcAt(c.cY, y0, y90, derivRoot));\r\n                    }\r\n                }\r\n            }\r\n            return command;\r\n        });\r\n        f.minX = Infinity;\r\n        f.maxX = -Infinity;\r\n        f.minY = Infinity;\r\n        f.maxY = -Infinity;\r\n        return f;\r\n    }\r\n    SVGPathDataTransformer.CALCULATE_BOUNDS = CALCULATE_BOUNDS;\r\n})(SVGPathDataTransformer || (SVGPathDataTransformer = {}));\r\n//# sourceMappingURL=SVGPathDataTransformer.js.map","map":"{\"version\":3,\"file\":\"SVGPathDataTransformer.js\",\"sourceRoot\":\"\",\"sources\":[\"src/SVGPathDataTransformer.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"C:/Users/aval/tsdev/SVGPathData/SVGPathDataTransformer.d.ts","text":"import { SVGCommand, TransformFunction } from \"./types\";\r\nexport declare namespace SVGPathDataTransformer {\r\n    function ROUND(roundVal?: number): (command: any) => any;\r\n    function TO_ABS(): (command: any) => any;\r\n    function TO_REL(): (command: any) => any;\r\n    function NORMALIZE_HVZ(normalizeZ?: boolean, normalizeH?: boolean, normalizeV?: boolean): (command: any) => any;\r\n    function NORMALIZE_ST(): (command: any) => any;\r\n    function QT_TO_C(): (command: any) => any;\r\n    function INFO(f: (command: any, prevXAbs: number, prevYAbs: number, pathStartXAbs: number, pathStartYAbs: number) => any | any[]): (command: any) => any;\r\n    function SANITIZE(EPS?: number): (command: any) => any;\r\n    function MATRIX(a: number, b: number, c: number, d: number, e: number, f: number): (command: any) => any;\r\n    function ROTATE(a: number, x?: number, y?: number): (command: any) => any;\r\n    function TRANSLATE(dX: number, dY?: number): (command: any) => any;\r\n    function SCALE(dX: number, dY?: number): (command: any) => any;\r\n    function SKEW_X(a: number): (command: any) => any;\r\n    function SKEW_Y(a: number): (command: any) => any;\r\n    function X_AXIS_SYMMETRY(xOffset?: number): (command: any) => any;\r\n    function Y_AXIS_SYMMETRY(yOffset?: number): (command: any) => any;\r\n    function A_TO_C(): (command: any) => any;\r\n    function ANNOTATE_ARCS(): (command: any) => any;\r\n    function CLONE(): (c: SVGCommand) => SVGCommand;\r\n    function CALCULATE_BOUNDS(): TransformFunction & {\r\n        minX: number;\r\n        maxX: number;\r\n        minY: number;\r\n        maxY: number;\r\n    };\r\n}\r\n"}}
